<!doctype html>
<html lang="hu">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0"
    />
    <title>Nations League âš½</title>
    
    <!-- ERUDA MOBILE DEBUG CONSOLE -->
    <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
    <script>eruda.init();</script>
    
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Russo+One&family=Barlow+Condensed:wght@400;600;700&display=swap");
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        user-select: none;
      }
      body {
        background: #0a0e17;
        font-family: "Barlow Condensed", sans-serif;
        overflow: hidden;
        width: 100vw;
        height: 100vh;
        display: flex;
        flex-direction: column;
        color: #fff;
      }
      #gameContainer {
        position: relative;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
      }
      #scoreboard {
        display: none;
        justify-content: center;
        align-items: center;
        gap: 8px;
        padding: 4px 0;
        background: linear-gradient(180deg, #111827, #0a0e17);
        z-index: 10;
        height: 50px;
        min-height: 50px;
      }
      #scoreboard.active {
        display: flex;
      }
      .ts {
        display: flex;
        align-items: center;
        gap: 5px;
        font-family: "Russo One", sans-serif;
      }
      .ts .fl {
        font-size: 20px;
      }
      .ts .tn {
        font-size: 11px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        max-width: 65px;
        overflow: hidden;
        white-space: nowrap;
      }
      .ts .sc {
        font-size: 28px;
        min-width: 24px;
        text-align: center;
      }
      .th .tn,
      .th .sc {
        color: #93c5fd;
      }
      .ta .tn,
      .ta .sc {
        color: #fca5a5;
      }
      #sd {
        font-size: 18px;
        color: #4b5563;
        font-family: "Russo One", sans-serif;
      }
      #gt {
        font-size: 9px;
        color: #6b7280;
        text-align: center;
      }
      canvas {
        flex: 1;
        display: block;
        touch-action: none;
      }
      .ov {
        position: absolute;
        inset: 0;
        z-index: 100;
        display: none;
        flex-direction: column;
        align-items: center;
        overflow-y: auto;
        background: rgba(10, 14, 23, 0.98);
      }
      .ov.a {
        display: flex;
      }
      .oc {
        width: 100%;
        max-width: 420px;
        padding: 14px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
      }
      h1.t {
        font-family: "Russo One", sans-serif;
        font-size: 26px;
        text-shadow: 0 0 30px rgba(250, 204, 21, 0.4);
        margin-top: 16px;
        text-align: center;
      }
      h2.s {
        font-family: "Russo One", sans-serif;
        font-size: 14px;
        color: #9ca3af;
        margin-bottom: 6px;
      }
      .b {
        background: linear-gradient(135deg, #1e40af, #3b82f6);
        border: none;
        color: #fff;
        font-family: "Russo One", sans-serif;
        font-size: 13px;
        padding: 11px 24px;
        border-radius: 8px;
        cursor: pointer;
        width: 100%;
        max-width: 420px;
        text-align: center;
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        display: block;
        margin: 0 auto 8px auto;
      }
      .b:active {
        transform: scale(0.97);
      }
      .b2 {
        background: linear-gradient(135deg, #374151, #4b5563);
        box-shadow: 0 4px 8px rgba(75, 85, 99, 0.3);
      }
      .bg {
        background: linear-gradient(135deg, #92400e, #f59e0b);
        box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3);
      }
      .br {
        background: linear-gradient(135deg, #991b1b, #ef4444);
      }
      .bs {
        font-size: 10px;
        padding: 7px 14px;
        min-width: 80px;
      }
      .tg {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 5px;
        width: 100%;
        max-height: 50vh;
        overflow-y: auto;
        padding: 2px;
      }
      .tc {
        background: #1f2937;
        border: 2px solid #374151;
        border-radius: 7px;
        padding: 7px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .tc:active,
      .tc.sel {
        border-color: #3b82f6;
        background: #1e3a5f;
      }
      .tc .f {
        font-size: 22px;
      }
      .tc .i {
        flex: 1;
        min-width: 0;
      }
      .tc .n {
        font-size: 11px;
        font-weight: 700;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .tc .r {
        font-size: 9px;
        color: #9ca3af;
      }
      .tc .o {
        font-family: "Russo One", sans-serif;
        font-size: 14px;
        color: #facc15;
      }
      .fg {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 5px;
        width: 100%;
      }
      .fb {
        background: #1f2937;
        border: 2px solid #374151;
        color: #d1d5db;
        font-family: "Barlow Condensed", sans-serif;
        font-size: 15px;
        font-weight: 600;
        padding: 9px;
        border-radius: 7px;
        cursor: pointer;
        text-align: center;
      }
      .fb:active,
      .fb.sel {
        border-color: #3b82f6;
        background: #1e3a5f;
        color: #fff;
      }
      .gt {
        width: 100%;
        border-collapse: collapse;
        font-size: 10px;
        margin-bottom: 6px;
      }
      .gt th {
        background: #1e293b;
        padding: 3px 5px;
        text-align: left;
        font-weight: 600;
        color: #9ca3af;
        font-size: 9px;
      }
      .gt td {
        padding: 3px 5px;
        border-bottom: 1px solid #1e293b;
      }
      .gt tr.q td {
        color: #22c55e;
      }
      .gt tr.e td {
        color: #6b7280;
      }
      .mr {
        font-size: 10px;
        color: #9ca3af;
        padding: 2px 5px;
      }
      #ti {
        position: absolute;
        top: 54px;
        left: 50%;
        transform: translateX(-50%);
        font-weight: 700;
        font-size: 11px;
        padding: 3px 10px;
        border-radius: 10px;
        z-index: 20;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        pointer-events: none;
        white-space: nowrap;
      }
      #go {
        position: absolute;
        inset: 0;
        z-index: 80;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        pointer-events: none;
      }
      #go.a {
        display: flex;
        animation: gf 2.5s ease-out forwards;
      }
      .gx {
        font-family: "Russo One", sans-serif;
        font-size: 52px;
        color: #fff;
        text-shadow: 0 0 60px rgba(250, 204, 21, 0.8);
        animation: gp 0.4s ease-in-out 3;
      }
      .gs {
        font-size: 16px;
        color: #facc15;
        font-weight: 700;
        margin-top: 4px;
      }
      @keyframes gf {
        0% {
          background: rgba(250, 204, 21, 0.3);
        }
        100% {
          background: transparent;
        }
      }
      @keyframes gp {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
      }
      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: scale(0.9);
        }
        to {
          opacity: 1;
          transform: scale(1);
        }
      }
      #pb {
        position: absolute;
        bottom: 14px;
        left: 50%;
        transform: translateX(-50%);
        width: 140px;
        height: 8px;
        background: rgba(17, 24, 39, 0.9);
        border-radius: 4px;
        overflow: visible; /* Changed from hidden to show marker */
        z-index: 30;
        display: none;
        border: 1px solid #374151;
      }
      /* 75% THRESHOLD MARKER */
      #pb::after {
        content: '';
        position: absolute;
        left: 75%; /* 75% position */
        top: -2px;
        bottom: -2px;
        width: 2px;
        background: rgba(255, 255, 255, 0.7);
        box-shadow: 0 0 4px rgba(255, 255, 255, 0.5);
      }
      #pf {
        height: 100%;
        width: 0%;
        border-radius: 4px;
      }
      #ins {
        position: absolute;
        bottom: 28px;
        left: 50%;
        transform: translateX(-50%);
        color: #6b7280;
        font-size: 10px;
        text-align: center;
        z-index: 20;
        pointer-events: none;
        white-space: nowrap;
      }
      #pi {
        position: absolute;
        background: rgba(17, 24, 39, 0.95);
        border: 1px solid #374151;
        border-radius: 7px;
        padding: 7px 9px;
        color: #fff;
        font-size: 10px;
        pointer-events: none;
        z-index: 50;
        display: none;
        min-width: 130px;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
      }
      #mo {
        position: absolute;
        inset: 0;
        z-index: 90;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: rgba(10, 14, 23, 0.95);
      }
      #mo.a {
        display: flex;
      }
      .mot {
        font-family: "Russo One", sans-serif;
        font-size: 22px;
        margin-bottom: 4px;
      }
      .mos {
        font-family: "Russo One", sans-serif;
        font-size: 44px;
        color: #facc15;
      }
      .mosb {
        font-size: 13px;
        color: #9ca3af;
        margin-bottom: 14px;
      }
      
      /* ============================================ */
      /* SQUAD BUILDER & SHOP STYLES */
      /* ============================================ */
      
      /* Tab Navigation */
      .tabs {
        display: flex;
        gap: 8px;
        margin-bottom: 12px;
        border-bottom: 2px solid #1f2937;
        padding-bottom: 8px;
      }
      .tab {
        background: #1f2937;
        border: none;
        color: #9ca3af;
        font-family: "Barlow Condensed", sans-serif;
        font-size: 14px;
        font-weight: 600;
        padding: 8px 16px;
        border-radius: 6px 6px 0 0;
        cursor: pointer;
        transition: all 0.2s;
      }
      .tab.active {
        background: #3b82f6;
        color: #fff;
      }
      
      /* Player Card */
      .player-card {
        background: linear-gradient(135deg, #1f2937 0%, #111827 100%);
        border: 2px solid #374151;
        border-radius: 8px;
        padding: 10px;
        cursor: pointer;
        transition: all 0.2s;
        position: relative;
      }
      .player-card:hover {
        border-color: #3b82f6;
        transform: translateY(-2px);
      }
      .player-card.selected {
        border-color: #facc15;
        background: linear-gradient(135deg, #422006 0%, #1f2937 100%);
      }
      
      /* Tier colors */
      .player-card.legendary {
        border-color: #fbbf24;
        box-shadow: 0 0 10px rgba(251, 191, 36, 0.3);
      }
      .player-card.epic {
        border-color: #a855f7;
        box-shadow: 0 0 10px rgba(168, 85, 247, 0.3);
      }
      .player-card.rare {
        border-color: #3b82f6;
        box-shadow: 0 0 10px rgba(59, 130, 246, 0.3);
      }
      .player-card.common {
        border-color: #6b7280;
      }
      
      .player-card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 6px;
      }
      .player-card-name {
        font-family: "Russo One", sans-serif;
        font-size: 13px;
        color: #fff;
      }
      .player-card-ovr {
        font-family: "Russo One", sans-serif;
        font-size: 18px;
        color: #facc15;
      }
      .player-card-info {
        font-size: 10px;
        color: #9ca3af;
        margin-bottom: 4px;
      }
      .player-card-country {
        font-size: 16px;
        margin-right: 4px;
      }
      .player-card-stats {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 3px;
        font-size: 9px;
        color: #d1d5db;
      }
      .player-card-stat {
        display: flex;
        justify-content: space-between;
      }
      .player-card-stat-label {
        color: #9ca3af;
      }
      
      /* Shop Pack Card */
      .pack-card {
        background: linear-gradient(135deg, #1f2937 0%, #111827 100%);
        border: 2px solid #374151;
        border-radius: 10px;
        padding: 16px;
        text-align: center;
        cursor: pointer;
        transition: all 0.2s;
      }
      .pack-card:hover {
        border-color: #3b82f6;
        transform: scale(1.05);
      }
      .pack-card:active {
        transform: scale(0.98);
      }
      .pack-card.disabled {
        opacity: 0.50;
        cursor: not-allowed;
      }
      .pack-card.disabled:hover {
        transform: none;
        border-color: #374151;
      }
      .pack-icon {
        font-size: 48px;
        margin-bottom: 8px;
      }
      .pack-name {
        font-family: "Russo One", sans-serif;
        font-size: 16px;
        color: #fff;
        margin-bottom: 4px;
      }
      .pack-info {
        font-size: 11px;
        color: #9ca3af;
        margin-bottom: 8px;
      }
      .pack-cost {
        font-family: "Russo One", sans-serif;
        font-size: 20px;
        color: #facc15;
      }
      
      /* Squad Formation Display */
      .formation-display {
        background: #0a1628;
        border: 2px solid #1f2937;
        border-radius: 10px;
        padding: 16px;
        margin-bottom: 12px;
        position: relative;
        aspect-ratio: 2/3;
      }
      .formation-player-slot {
        position: absolute;
        width: 50px;
        height: 60px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s;
      }
      .formation-player-slot:hover {
        transform: scale(1.1);
      }
      .formation-player-circle {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #1f2937;
        border: 2px solid #374151;
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: "Russo One", sans-serif;
        font-size: 16px;
        color: #9ca3af;
        margin-bottom: 2px;
      }
      .formation-player-slot.filled .formation-player-circle {
        background: #3b82f6;
        border-color: #60a5fa;
        color: #fff;
      }
      .formation-player-name {
        font-size: 8px;
        color: #9ca3af;
        text-align: center;
        white-space: nowrap;
      }
      
      /* Grid layouts */
      .players-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
        max-height: 400px;
        overflow-y: auto;
      }
      .packs-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
      }
      
      /* Pack Opening Animation */
      .pack-opening {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.95);
        z-index: 9999;
        display: none;
        align-items: center;
        justify-content: center;
        flex-direction: column;
      }
      .pack-opening.active {
        display: flex;
      }
      .pack-opening-card {
        background: linear-gradient(135deg, #1f2937 0%, #111827 100%);
        border: 3px solid #fbbf24;
        border-radius: 12px;
        padding: 20px;
        min-width: 280px;
        text-align: center;
        animation: cardReveal 0.5s ease-out;
      }
      @keyframes cardReveal {
        from {
          transform: scale(0) rotateY(180deg);
          opacity: 0.00;
        }
        to {
          transform: scale(1) rotateY(0deg);
          opacity: 1.00;
        }
      }
      
      ::-webkit-scrollbar {
        width: 3px;
      }
      ::-webkit-scrollbar-track {
        background: #0a0e17;
      }
      ::-webkit-scrollbar-thumb {
        background: #374151;
        border-radius: 2px;
      }
      /* Hide scrollbar for carousel (slideshow effect) */
      #formationCarousel::-webkit-scrollbar {
        display: none;
      }
      #formationCarousel {
        -ms-overflow-style: none;
        scrollbar-width: none;
      }
    </style>
  </head>
  <body>
    <div id="gameContainer">
      <div id="scoreboard">
        <div class="ts th">
          <span class="fl" id="hf"></span><span class="tn" id="hn"></span
          ><span class="sc" id="hs">0</span>
        </div>
        <div style="text-align: center">
          <div id="sd">-</div>
          <div id="gt">90 perc</div>
        </div>
        <div class="ts ta">
          <span class="sc" id="as">0</span><span class="tn" id="an"></span
          ><span class="fl" id="af"></span>
        </div>
        <!-- PAUSE BUTTON (top-right) -->
        <button id="pauseBtn" onclick="togglePause()" style="
          position: absolute;
          top: 8px;
          right: 8px;
          background: rgba(31, 41, 55, 0.9);
          border: 1px solid #374151;
          border-radius: 6px;
          color: #fff;
          padding: 6px 10px;
          font-size: 12px;
          font-family: 'Barlow Condensed', sans-serif;
          cursor: pointer;
          display: none;
        ">â¸ PAUSE</button>
      </div>
      
      <!-- PAUSE MENU OVERLAY -->
      <div id="pauseMenu" style="
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.85);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 9998;
      ">
        <div style="
          background: #1f2937;
          border: 2px solid #374151;
          border-radius: 12px;
          padding: 24px;
          text-align: center;
          min-width: 250px;
        ">
          <h2 style="
            font-family: 'Russo One', sans-serif;
            font-size: 24px;
            color: #facc15;
            margin-bottom: 20px;
          ">â¸ PAUSED</h2>
          <button onclick="togglePause()" class="mb" style="
            width: 100%;
            margin-bottom: 10px;
            background: #10b981;
          ">â–¶ RESUME</button>
          <button onclick="giveUpMatch()" class="mb" style="
            width: 100%;
            background: #ef4444;
          ">ğŸ³ï¸ GIVE UP</button>
        </div>
      </div>
      
      <!-- PLAYER SYSTEM DEBUG (top-right corner) -->
      <div id="playerDebug" style="
        position: fixed;
        top: 10px;
        right: 10px;
        background: rgba(17, 24, 39, 0.95);
        padding: 8px 12px;
        border-radius: 8px;
        font-size: 11px;
        color: #9ca3af;
        z-index: 1000;
        font-family: 'Barlow Condensed', sans-serif;
        display: none;
      ">
        <div style="color: #fbbf24; font-weight: 600; margin-bottom: 4px;">âš½ Player System</div>
        <div>Level: <span id="debugLevel">1</span> (<span id="debugXP">0</span>/<span id="debugNextXP">1000</span> XP)</div>
        <div>Coins: <span id="debugCoins" style="color: #fbbf24;">0</span></div>
        <div>Players: <span id="debugPlayers">0</span></div>
      </div>
      
      <canvas id="gameCanvas"></canvas>
      <div id="ti"></div>
      <div id="pi"></div>
      <div id="pb"><div id="pf"></div></div>
      <div id="ins"></div>
      <div id="go">
        <div class="gx">âš½ GÃ“L!</div>
        <div class="gs" id="gsc"></div>
      </div>
      <div id="mo">
        <div class="mot" id="moT"></div>
        <div class="mos" id="moS"></div>
        <div class="mosb" id="moSb"></div>
        <button class="b" onclick="moCont()">Continue</button>
      </div>
      <div class="ov a" id="menu">
        <div class="oc">
          <h1 class="t">âš½ Football Manager 2026</h1>
          <h2 class="s">Main Menu</h2>
          
          <!-- Player System Buttons -->
          <button class="b" onclick="openSquadBuilder()" style="background: linear-gradient(135deg, #3b82f6, #1e40af); border: none;">
            ğŸ‘¥ My Squad
          </button>
          <button class="b" onclick="openShop()" style="background: linear-gradient(135deg, #f59e0b, #d97706); border: none;">
            ğŸ›’ Shop
          </button>
          
          <h2 class="s" style="margin-top: 16px;">Choose Tournament</h2>
          <button class="b" onclick="openQM()">âš¡ Quick Match</button>
          <button class="b" onclick="selectCup('EURO')">ğŸ† EURO 2028 (55 teams)</button>
          <button class="b" onclick="selectCup('AFCON')">ğŸ† AFCON 2025 (54 teams)</button>
          <button class="b" onclick="selectCup('COPA')">ğŸ† Copa America 2024 (16 teams)</button>
          <button class="b" onclick="selectCup('AFC')">ğŸ† Asian Cup 2027 (47 teams)</button>
          <button class="b" onclick="selectCup('CONCACAF')">ğŸ† Gold Cup 2025 (41 teams)</button>
          <button class="b bg" onclick="selectCup('WC')">ğŸŒ World Championship (Qualifiers + Finals)</button>
        </div>
      </div>
      <div class="ov" id="tsel">

        <div class="oc">
          <h2 class="s" id="tst"></h2>
          
          <input
            type="text"
            id="tsrch"
            placeholder="Search..."
            style="
              width: 100%;
              padding: 7px 10px;
              border-radius: 6px;
              border: 1px solid #374151;
              background: #1f2937;
              color: #fff;
              font-size: 13px;
              outline: none;
            "
            oninput="filt()"
          />
          <div class="tg" id="tgr"></div>
          <button class="b b2 bs" onclick="bMenu()">Back</button>
        </div>
      </div>
      <div class="ov" id="fsel">
        <div class="oc">
          <h2 class="s" id="fst"></h2>
          <div class="fg" id="fgr"></div>
          <button class="b b2 bs" onclick="bTS()">Back</button>
        </div>
      </div>
      <div class="ov" id="cup"><div class="oc" id="cupc"></div></div>
      
      <!-- SQUAD BUILDER OVERLAY -->
      <div class="ov" id="squadBuilder">
        <div class="oc">
          <h2 class="s">ğŸ‘¥ My Squad</h2>
          
          <!-- User Stats -->
          <div style="background: #1f2937; padding: 10px; border-radius: 8px; margin-bottom: 12px; display: flex; justify-content: space-between; align-items: center;">
            <div>
              <div style="font-size: 11px; color: #9ca3af;">Level <span id="sbLevel">1</span></div>
              <div style="font-size: 9px; color: #6b7280;"><span id="sbXP">0</span>/<span id="sbNextXP">1000</span> XP</div>
            </div>
            <div style="text-align: right;">
              <div style="font-family: 'Russo One', sans-serif; font-size: 18px; color: #facc15;">
                <span id="sbCoins">0</span> ğŸ’°
              </div>
              <div style="font-size: 9px; color: #6b7280;"><span id="sbPlayers">0</span> players</div>
            </div>
          </div>
          
          <!-- Tabs -->
          <div class="tabs">
            <button class="tab active" onclick="switchSquadTab('lineup')">Starting XI</button>
            <button class="tab" onclick="switchSquadTab('collection')">Collection</button>
          </div>
          
          <!-- LINEUP TAB -->
          <div id="squadLineup">
            <div style="font-size: 11px; color: #9ca3af; margin-bottom: 8px;">
              Current Formation: <span id="currentFormation" style="color: #facc15; font-weight: 600;">4-4-2</span>
            </div>
            <button class="mb" onclick="openFormationsMenu()" style="width: 100%; margin-bottom: 12px;">
              âš™ï¸ CHANGE FORMATION
            </button>
            
            <!-- Formation Display -->
            <div class="formation-display" id="formationDisplay">
              <!-- Will be populated by JS -->
            </div>
            
            <button class="b" onclick="autoSelectBest()">âš¡ Auto-Select Best XI</button>
          </div>
          
          <!-- COLLECTION TAB -->
          <div id="squadCollection" style="display: none;">
            <input
              type="text"
              id="collectionSearch"
              placeholder="Search players..."
              style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #374151; background: #1f2937; color: #fff; font-size: 13px; margin-bottom: 10px;"
              oninput="filterCollection()"
            />
            
            <div style="font-size: 10px; color: #9ca3af; margin-bottom: 4px;">Filter by Tier:</div>
            <div style="display: flex; gap: 6px; margin-bottom: 10px; flex-wrap: wrap;">
              <button class="fb" onclick="filterByTier('all')">All</button>
              <button class="fb" onclick="filterByTier('legendary')">â­ Legendary</button>
              <button class="fb" onclick="filterByTier('epic')">ğŸŸ£ Epic</button>
              <button class="fb" onclick="filterByTier('rare')">ğŸ”µ Rare</button>
              <button class="fb" onclick="filterByTier('common')">âšª Common</button>
            </div>
            
            <div style="font-size: 10px; color: #9ca3af; margin-bottom: 4px;">Filter by Position:</div>
            <div style="display: flex; gap: 4px; margin-bottom: 10px; flex-wrap: wrap; font-size: 11px;">
              <button class="fb" onclick="filterByPosition('all')">All</button>
              <button class="fb" onclick="filterByPosition('GK')">GK</button>
              <button class="fb" onclick="filterByPosition('DEF')">DEF</button>
              <button class="fb" onclick="filterByPosition('MID')">MID</button>
              <button class="fb" onclick="filterByPosition('ATT')">ATT</button>
            </div>
            
            <div class="players-grid" id="collectionGrid">
              <!-- Will be populated by JS -->
            </div>
          </div>
          
          <button class="b b2 bs" onclick="closeSquadBuilder()">Back</button>
        </div>
      </div>
      
      <!-- SHOP OVERLAY -->
      <div class="ov" id="shop">
        <div class="oc">
          <h2 class="s">ğŸ›’ Shop</h2>
          
          <!-- User Coins -->
          <div style="background: #1f2937; padding: 12px; border-radius: 8px; margin-bottom: 16px; text-align: center;">
            <div style="font-size: 11px; color: #9ca3af; margin-bottom: 4px;">Your Balance</div>
            <div style="font-family: 'Russo One', sans-serif; font-size: 32px; color: #facc15;">
              <span id="shopCoins">0</span> ğŸ’°
            </div>
          </div>
          
          <!-- Packs Grid -->
          <div class="packs-grid">
            <!-- Bronze Pack -->
            <div class="pack-card" onclick="buyPack('bronze')">
              <div class="pack-icon">ğŸ“¦</div>
              <div class="pack-name">Bronze Pack</div>
              <div class="pack-info">3 players<br>75% Common, 24% Rare</div>
              <div class="pack-cost">200 ğŸ’°</div>
            </div>
            
            <!-- Silver Pack -->
            <div class="pack-card" onclick="buyPack('silver')">
              <div class="pack-icon">ğŸ“¦</div>
              <div class="pack-name">Silver Pack</div>
              <div class="pack-info">5 players<br>60% Common, 30% Rare, 9% Epic</div>
              <div class="pack-cost">500 ğŸ’°</div>
            </div>
            
            <!-- Gold Pack -->
            <div class="pack-card" onclick="buyPack('gold')">
              <div class="pack-icon">ğŸ</div>
              <div class="pack-name">Gold Pack</div>
              <div class="pack-info">5 players<br>50% Rare, 25% Epic, 5% Legendary</div>
              <div class="pack-cost">1500 ğŸ’°</div>
            </div>
            
            <!-- Premium Pack -->
            <div class="pack-card" onclick="buyPack('premium')">
              <div class="pack-icon">ğŸ’</div>
              <div class="pack-name">Premium Pack</div>
              <div class="pack-info">7 players<br>1 Legendary guaranteed!</div>
              <div class="pack-cost">3000 ğŸ’°</div>
            </div>
          </div>
          
          <button class="b b2 bs" style="margin-top: 16px;" onclick="closeShop()">Back</button>
        </div>
      </div>
      <!-- FORMATIONS MENU OVERLAY -->
      <div class="ov" id="formationsMenu">
        <div class="oc" style="max-width: 600px; overflow-x: hidden; overflow-y: auto; max-height: 90vh; display: flex; flex-direction: column;">
          <h2 class="s">âš™ï¸ Formations</h2>
          
          <!-- Selected Formation Preview (Big) -->
          <div id="selectedFormationPreview" style="
            background: linear-gradient(135deg, #1e3a4a, #0f1f2a);
            border: 2px solid #374151;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
            min-height: 280px;
            position: relative;
          ">
            <div style="text-align: center; margin-bottom: 12px;">
              <div id="selectedFormationName" style="
                font-family: 'Russo One', sans-serif;
                font-size: 32px;
                color: #facc15;
              ">4-4-2</div>
              <div id="selectedFormationStatus" style="
                font-size: 12px;
                color: #10b981;
                margin-top: 4px;
              ">âœ“ UNLOCKED</div>
            </div>
            
            <!-- Big Formation Visualization -->
            <canvas id="formationPreviewCanvas" width="500" height="300" style="
              width: 100%;
              height: auto;
              border-radius: 8px;
            "></canvas>
            
            <!-- Select Button -->
            <button id="selectFormationBtn" onclick="selectFormation()" class="mb" style="
              width: 100%;
              margin-top: 12px;
              background: #10b981;
            ">âœ“ SELECT THIS FORMATION</button>
          </div>
          
          <!-- Formation Cards Carousel (Small) -->
          <div style="margin-bottom: 16px; flex-shrink: 0;">
            <div style="
              font-size: 11px;
              color: #9ca3af;
              margin-bottom: 8px;
              text-align: center;
            ">Swipe to browse formations â†’</div>
            
            <div id="formationCarousel" style="
              display: flex;
              gap: 12px;
              overflow-x: scroll;
              overflow-y: hidden;
              padding: 8px 4px;
              scroll-snap-type: x mandatory;
              -webkit-overflow-scrolling: touch;
              max-height: 180px;
              touch-action: pan-x;
              scrollbar-width: none;
            ">
              <!-- Formation cards will be inserted here by JS -->
            </div>
          </div>
          
          <button class="b b2 bs" onclick="closeFormationsMenu()">Back</button>
        </div>
      </div>
      
      <!-- PACK OPENING ANIMATION -->
      <div class="pack-opening" id="packOpening">
        <div class="pack-opening-card" id="packCard">
          <!-- Will be populated by JS -->
        </div>
        <button class="b" style="margin-top: 20px;" onclick="closePackOpening()">Continue</button>
      </div>
    </div>

    <script>
      // Helper: Calculate My Squad average rating
      function getMySquadAverageRating() {
        if (G.userSquad.players.length === 0) return 65;
        
        const players = G.userSquad.players
          .slice(0, 11) // First 11 only
          .map(id => getPlayerById(id))
          .filter(p => p);
        
        if (players.length === 0) return 65;
        
        const avgOverall = players.reduce((sum, p) => sum + p.overall, 0) / players.length;
        return Math.round(avgOverall);
      }
      
      // Cache for national team ratings (calculated once)
      const NATIONAL_TEAM_RATINGS = {};
      
      // Calculate national team average rating from database
      function getNationalTeamAverageRating(countryCode) {
        // Return cached if exists
        if (NATIONAL_TEAM_RATINGS[countryCode]) {
          return NATIONAL_TEAM_RATINGS[countryCode];
        }
        
        const formation = getCountryFormation(countryCode);
        const squad = generateNationalSquad(countryCode, formation);
        
        let rating;
        if (!squad || squad.filter(p => p).length === 0) {
          // No players in DB - use FIFA rank to estimate
          const team = TEAMS.find(t => t.code === countryCode);
          if (!team) {
            rating = 75;
          } else {
            if (team.rank <= 10) rating = 85;
            else if (team.rank <= 30) rating = 80;
            else if (team.rank <= 80) rating = 75;
            else rating = 70;
          }
        } else {
          const validPlayers = squad.filter(p => p);
          rating = Math.round(validPlayers.reduce((sum, p) => sum + p.overall, 0) / validPlayers.length);
        }
        
        // Cache it
        NATIONAL_TEAM_RATINGS[countryCode] = rating;
        return rating;
      }
      
      const TEAMS = [
        // MY SQUAD - Dynamic team based on user's players
        { 
          name: "My Squad", 
          code: "MY_SQUAD", 
          flag: "âš½", 
          rank: 0, 
          continent: "MY_SQUAD",
          isMySquad: true,
          get avgRating() { return getMySquadAverageRating(); }
        },
        
        // EUROPE (UEFA) - 55 teams (COMPLETE)
        { name: "Spain", code: "ESP", flag: "ğŸ‡ªğŸ‡¸", rank: 1, continent: "UEFA" },
        { name: "France", code: "FRA", flag: "ğŸ‡«ğŸ‡·", rank: 3, continent: "UEFA" },
        { name: "England", code: "ENG", flag: "ğŸ´ó §ó ¢ó ¥ó ®ó §ó ¿", rank: 4, continent: "UEFA" },
        { name: "Portugal", code: "POR", flag: "ğŸ‡µğŸ‡¹", rank: 6, continent: "UEFA" },
        { name: "Netherlands", code: "NED", flag: "ğŸ‡³ğŸ‡±", rank: 7, continent: "UEFA" },
        { name: "Belgium", code: "BEL", flag: "ğŸ‡§ğŸ‡ª", rank: 9, continent: "UEFA" },
        { name: "Germany", code: "GER", flag: "ğŸ‡©ğŸ‡ª", rank: 10, continent: "UEFA" },
        { name: "Croatia", code: "CRO", flag: "ğŸ‡­ğŸ‡·", rank: 11, continent: "UEFA" },
        { name: "Italy", code: "ITA", flag: "ğŸ‡®ğŸ‡¹", rank: 17, continent: "UEFA" },
        { name: "Switzerland", code: "SUI", flag: "ğŸ‡¨ğŸ‡­", rank: 18, continent: "UEFA" },
        { name: "Denmark", code: "DEN", flag: "ğŸ‡©ğŸ‡°", rank: 21, continent: "UEFA" },
        { name: "Austria", code: "AUT", flag: "ğŸ‡¦ğŸ‡¹", rank: 24, continent: "UEFA" },
        { name: "Turkey", code: "TUR", flag: "ğŸ‡¹ğŸ‡·", rank: 25, continent: "UEFA" },
        { name: "Ukraine", code: "UKR", flag: "ğŸ‡ºğŸ‡¦", rank: 27, continent: "UEFA" },
        { name: "Norway", code: "NOR", flag: "ğŸ‡³ğŸ‡´", rank: 28, continent: "UEFA" },
        { name: "Poland", code: "POL", flag: "ğŸ‡µğŸ‡±", rank: 30, continent: "UEFA" },
        { name: "Wales", code: "WAL", flag: "ğŸ´ó §ó ¢ó ·ó ¬ó ³ó ¿", rank: 31, continent: "UEFA" },
        { name: "Scotland", code: "SCO", flag: "ğŸ´ó §ó ¢ó ³ó £ó ´ó ¿", rank: 34, continent: "UEFA" },
        { name: "Serbia", code: "SRB", flag: "ğŸ‡·ğŸ‡¸", rank: 35, continent: "UEFA" },
        { name: "Hungary", code: "HUN", flag: "ğŸ‡­ğŸ‡º", rank: 39, continent: "UEFA" },
        { name: "Sweden", code: "SWE", flag: "ğŸ‡¸ğŸ‡ª", rank: 41, continent: "UEFA" },
        { name: "Czech Republic", code: "CZE", flag: "ğŸ‡¨ğŸ‡¿", rank: 42, continent: "UEFA" },
        { name: "Slovakia", code: "SVK", flag: "ğŸ‡¸ğŸ‡°", rank: 43, continent: "UEFA" },
        { name: "Greece", code: "GRE", flag: "ğŸ‡¬ğŸ‡·", rank: 44, continent: "UEFA" },
        { name: "Romania", code: "ROU", flag: "ğŸ‡·ğŸ‡´", rank: 45, continent: "UEFA" },
        { name: "Slovenia", code: "SVN", flag: "ğŸ‡¸ğŸ‡®", rank: 51, continent: "UEFA" },
        { name: "Albania", code: "ALB", flag: "ğŸ‡¦ğŸ‡±", rank: 52, continent: "UEFA" },
        { name: "Ireland", code: "IRL", flag: "ğŸ‡®ğŸ‡ª", rank: 53, continent: "UEFA" },
        { name: "Bosnia", code: "BIH", flag: "ğŸ‡§ğŸ‡¦", rank: 56, continent: "UEFA" },
        { name: "Georgia", code: "GEO", flag: "ğŸ‡¬ğŸ‡ª", rank: 57, continent: "UEFA" },
        { name: "Iceland", code: "ISL", flag: "ğŸ‡®ğŸ‡¸", rank: 58, continent: "UEFA" },
        { name: "Finland", code: "FIN", flag: "ğŸ‡«ğŸ‡®", rank: 59, continent: "UEFA" },
        { name: "Northern Ireland", code: "NIR", flag: "ğŸ‡¬ğŸ‡§", rank: 65, continent: "UEFA" },
        { name: "Bulgaria", code: "BUL", flag: "ğŸ‡§ğŸ‡¬", rank: 66, continent: "UEFA" },
        { name: "Montenegro", code: "MNE", flag: "ğŸ‡²ğŸ‡ª", rank: 67, continent: "UEFA" },
        { name: "North Macedonia", code: "MKD", flag: "ğŸ‡²ğŸ‡°", rank: 68, continent: "UEFA" },
        { name: "Israel", code: "ISR", flag: "ğŸ‡®ğŸ‡±", rank: 69, continent: "UEFA" },
        { name: "Cyprus", code: "CYP", flag: "ğŸ‡¨ğŸ‡¾", rank: 70, continent: "UEFA" },
        { name: "Armenia", code: "ARM", flag: "ğŸ‡¦ğŸ‡²", rank: 71, continent: "UEFA" },
        { name: "Belarus", code: "BLR", flag: "ğŸ‡§ğŸ‡¾", rank: 72, continent: "UEFA" },
        { name: "Kosovo", code: "KVX", flag: "ğŸ‡½ğŸ‡°", rank: 73, continent: "UEFA" },
        { name: "Luxembourg", code: "LUX", flag: "ğŸ‡±ğŸ‡º", rank: 74, continent: "UEFA" },
        { name: "Azerbaijan", code: "AZE", flag: "ğŸ‡¦ğŸ‡¿", rank: 75, continent: "UEFA" },
        { name: "Kazakhstan", code: "KAZ", flag: "ğŸ‡°ğŸ‡¿", rank: 76, continent: "UEFA" },
        { name: "Lithuania", code: "LTU", flag: "ğŸ‡±ğŸ‡¹", rank: 77, continent: "UEFA" },
        { name: "Latvia", code: "LVA", flag: "ğŸ‡±ğŸ‡»", rank: 78, continent: "UEFA" },
        { name: "Estonia", code: "EST", flag: "ğŸ‡ªğŸ‡ª", rank: 79, continent: "UEFA" },
        { name: "Faroe Islands", code: "FRO", flag: "ğŸ‡«ğŸ‡´", rank: 80, continent: "UEFA" },
        { name: "Malta", code: "MLT", flag: "ğŸ‡²ğŸ‡¹", rank: 81, continent: "UEFA" },
        { name: "Moldova", code: "MDA", flag: "ğŸ‡²ğŸ‡©", rank: 82, continent: "UEFA" },
        { name: "Liechtenstein", code: "LIE", flag: "ğŸ‡±ğŸ‡®", rank: 83, continent: "UEFA" },
        { name: "Andorra", code: "AND", flag: "ğŸ‡¦ğŸ‡©", rank: 84, continent: "UEFA" },
        { name: "San Marino", code: "SMR", flag: "ğŸ‡¸ğŸ‡²", rank: 85, continent: "UEFA" },
        { name: "Gibraltar", code: "GIB", flag: "ğŸ‡¬ğŸ‡®", rank: 86, continent: "UEFA" },

        // SOUTH AMERICA (CONMEBOL) - 10 teams (ALL)
        { name: "Argentina", code: "ARG", flag: "ğŸ‡¦ğŸ‡·", rank: 2, continent: "CONMEBOL" },
        { name: "Brazil", code: "BRA", flag: "ğŸ‡§ğŸ‡·", rank: 5, continent: "CONMEBOL" },
        { name: "Colombia", code: "COL", flag: "ğŸ‡¨ğŸ‡´", rank: 13, continent: "CONMEBOL" },
        { name: "Uruguay", code: "URU", flag: "ğŸ‡ºğŸ‡¾", rank: 14, continent: "CONMEBOL" },
        { name: "Ecuador", code: "ECU", flag: "ğŸ‡ªğŸ‡¨", rank: 23, continent: "CONMEBOL" },
        { name: "Paraguay", code: "PAR", flag: "ğŸ‡µğŸ‡¾", rank: 37, continent: "CONMEBOL" },
        { name: "Venezuela", code: "VEN", flag: "ğŸ‡»ğŸ‡ª", rank: 46, continent: "CONMEBOL" },
        { name: "Chile", code: "CHI", flag: "ğŸ‡¨ğŸ‡±", rank: 47, continent: "CONMEBOL" },
        { name: "Peru", code: "PER", flag: "ğŸ‡µğŸ‡ª", rank: 48, continent: "CONMEBOL" },
        { name: "Bolivia", code: "BOL", flag: "ğŸ‡§ğŸ‡´", rank: 49, continent: "CONMEBOL" },

        // AFRICA (CAF) - 54 teams (COMPLETE)
        { name: "Morocco", code: "MAR", flag: "ğŸ‡²ğŸ‡¦", rank: 8, continent: "CAF" },
        { name: "Senegal", code: "SEN", flag: "ğŸ‡¸ğŸ‡³", rank: 12, continent: "CAF" },
        { name: "Egypt", code: "EGY", flag: "ğŸ‡ªğŸ‡¬", rank: 32, continent: "CAF" },
        { name: "Algeria", code: "ALG", flag: "ğŸ‡©ğŸ‡¿", rank: 33, continent: "CAF" },
        { name: "Nigeria", code: "NGA", flag: "ğŸ‡³ğŸ‡¬", rank: 36, continent: "CAF" },
        { name: "Tunisia", code: "TUN", flag: "ğŸ‡¹ğŸ‡³", rank: 38, continent: "CAF" },
        { name: "Ivory Coast", code: "CIV", flag: "ğŸ‡¨ğŸ‡®", rank: 40, continent: "CAF" },
        { name: "South Africa", code: "RSA", flag: "ğŸ‡¿ğŸ‡¦", rank: 50, continent: "CAF" },
        { name: "Cameroon", code: "CMR", flag: "ğŸ‡¨ğŸ‡²", rank: 54, continent: "CAF" },
        { name: "Ghana", code: "GHA", flag: "ğŸ‡¬ğŸ‡­", rank: 60, continent: "CAF" },
        { name: "Mali", code: "MLI", flag: "ğŸ‡²ğŸ‡±", rank: 61, continent: "CAF" },
        { name: "DR Congo", code: "COD", flag: "ğŸ‡¨ğŸ‡©", rank: 62, continent: "CAF" },
        { name: "Burkina Faso", code: "BFA", flag: "ğŸ‡§ğŸ‡«", rank: 64, continent: "CAF" },
        { name: "Guinea", code: "GUI", flag: "ğŸ‡¬ğŸ‡³", rank: 87, continent: "CAF" },
        { name: "Zambia", code: "ZAM", flag: "ğŸ‡¿ğŸ‡²", rank: 88, continent: "CAF" },
        { name: "Gabon", code: "GAB", flag: "ğŸ‡¬ğŸ‡¦", rank: 89, continent: "CAF" },
        { name: "Angola", code: "ANG", flag: "ğŸ‡¦ğŸ‡´", rank: 90, continent: "CAF" },
        { name: "Benin", code: "BEN", flag: "ğŸ‡§ğŸ‡¯", rank: 91, continent: "CAF" },
        { name: "Uganda", code: "UGA", flag: "ğŸ‡ºğŸ‡¬", rank: 92, continent: "CAF" },
        { name: "Guinea-Bissau", code: "GNB", flag: "ğŸ‡¬ğŸ‡¼", rank: 93, continent: "CAF" },
        { name: "Kenya", code: "KEN", flag: "ğŸ‡°ğŸ‡ª", rank: 94, continent: "CAF" },
        { name: "Mauritania", code: "MTN", flag: "ğŸ‡²ğŸ‡·", rank: 95, continent: "CAF" },
        { name: "Mozambique", code: "MOZ", flag: "ğŸ‡²ğŸ‡¿", rank: 96, continent: "CAF" },
        { name: "Equatorial Guinea", code: "EQG", flag: "ğŸ‡¬ğŸ‡¶", rank: 97, continent: "CAF" },
        { name: "Namibia", code: "NAM", flag: "ğŸ‡³ğŸ‡¦", rank: 98, continent: "CAF" },
        { name: "Zimbabwe", code: "ZIM", flag: "ğŸ‡¿ğŸ‡¼", rank: 99, continent: "CAF" },
        { name: "Tanzania", code: "TAN", flag: "ğŸ‡¹ğŸ‡¿", rank: 100, continent: "CAF" },
        { name: "Central Africa", code: "CTA", flag: "ğŸ‡¨ğŸ‡«", rank: 101, continent: "CAF" },
        { name: "Togo", code: "TOG", flag: "ğŸ‡¹ğŸ‡¬", rank: 102, continent: "CAF" },
        { name: "Niger", code: "NIG", flag: "ğŸ‡³ğŸ‡ª", rank: 103, continent: "CAF" },
        { name: "Comoros", code: "COM", flag: "ğŸ‡°ğŸ‡²", rank: 104, continent: "CAF" },
        { name: "Sierra Leone", code: "SLE", flag: "ğŸ‡¸ğŸ‡±", rank: 105, continent: "CAF" },
        { name: "Malawi", code: "MWI", flag: "ğŸ‡²ğŸ‡¼", rank: 106, continent: "CAF" },
        { name: "Madagascar", code: "MAD", flag: "ğŸ‡²ğŸ‡¬", rank: 107, continent: "CAF" },
        { name: "Liberia", code: "LBR", flag: "ğŸ‡±ğŸ‡·", rank: 108, continent: "CAF" },
        { name: "Botswana", code: "BOT", flag: "ğŸ‡§ğŸ‡¼", rank: 109, continent: "CAF" },
        { name: "Gambia", code: "GAM", flag: "ğŸ‡¬ğŸ‡²", rank: 110, continent: "CAF" },
        { name: "Sudan", code: "SDN", flag: "ğŸ‡¸ğŸ‡©", rank: 111, continent: "CAF" },
        { name: "Ethiopia", code: "ETH", flag: "ğŸ‡ªğŸ‡¹", rank: 112, continent: "CAF" },
        { name: "Rwanda", code: "RWA", flag: "ğŸ‡·ğŸ‡¼", rank: 113, continent: "CAF" },
        { name: "Burundi", code: "BDI", flag: "ğŸ‡§ğŸ‡®", rank: 114, continent: "CAF" },
        { name: "Libya", code: "LBY", flag: "ğŸ‡±ğŸ‡¾", rank: 115, continent: "CAF" },
        { name: "Congo", code: "CGO", flag: "ğŸ‡¨ğŸ‡¬", rank: 116, continent: "CAF" },
        { name: "South Sudan", code: "SSD", flag: "ğŸ‡¸ğŸ‡¸", rank: 117, continent: "CAF" },
        { name: "Mauritius", code: "MRI", flag: "ğŸ‡²ğŸ‡º", rank: 118, continent: "CAF" },
        { name: "Eswatini", code: "SWZ", flag: "ğŸ‡¸ğŸ‡¿", rank: 119, continent: "CAF" },
        { name: "Chad", code: "CHA", flag: "ğŸ‡¹ğŸ‡©", rank: 120, continent: "CAF" },
        { name: "Lesotho", code: "LES", flag: "ğŸ‡±ğŸ‡¸", rank: 121, continent: "CAF" },
        { name: "Cape Verde", code: "CPV", flag: "ğŸ‡¨ğŸ‡»", rank: 122, continent: "CAF" },
        { name: "Sao Tome", code: "STP", flag: "ğŸ‡¸ğŸ‡¹", rank: 123, continent: "CAF" },
        { name: "Seychelles", code: "SEY", flag: "ğŸ‡¸ğŸ‡¨", rank: 124, continent: "CAF" },
        { name: "Djibouti", code: "DJI", flag: "ğŸ‡©ğŸ‡¯", rank: 125, continent: "CAF" },
        { name: "Somalia", code: "SOM", flag: "ğŸ‡¸ğŸ‡´", rank: 126, continent: "CAF" },
        { name: "Eritrea", code: "ERI", flag: "ğŸ‡ªğŸ‡·", rank: 127, continent: "CAF" },

        // ASIA (AFC) - 24 selected teams
        { name: "Japan", code: "JPN", flag: "ğŸ‡¯ğŸ‡µ", rank: 19, continent: "AFC" },
        { name: "Iran", code: "IRN", flag: "ğŸ‡®ğŸ‡·", rank: 20, continent: "AFC" },
        { name: "South Korea", code: "KOR", flag: "ğŸ‡°ğŸ‡·", rank: 22, continent: "AFC" },
        { name: "Australia", code: "AUS", flag: "ğŸ‡¦ğŸ‡º", rank: 26, continent: "AFC" },
        { name: "Uzbekistan", code: "UZB", flag: "ğŸ‡ºğŸ‡¿", rank: 47, continent: "AFC" },
        { name: "Qatar", code: "QAT", flag: "ğŸ‡¶ğŸ‡¦", rank: 48, continent: "AFC" },
        { name: "Saudi Arabia", code: "KSA", flag: "ğŸ‡¸ğŸ‡¦", rank: 49, continent: "AFC" },
        { name: "Iraq", code: "IRQ", flag: "ğŸ‡®ğŸ‡¶", rank: 55, continent: "AFC" },
        { name: "UAE", code: "UAE", flag: "ğŸ‡¦ğŸ‡ª", rank: 128, continent: "AFC" },
        { name: "Oman", code: "OMA", flag: "ğŸ‡´ğŸ‡²", rank: 129, continent: "AFC" },
        { name: "Jordan", code: "JOR", flag: "ğŸ‡¯ğŸ‡´", rank: 130, continent: "AFC" },
        { name: "Bahrain", code: "BHR", flag: "ğŸ‡§ğŸ‡­", rank: 131, continent: "AFC" },
        { name: "China", code: "CHN", flag: "ğŸ‡¨ğŸ‡³", rank: 132, continent: "AFC" },
        { name: "Palestine", code: "PLE", flag: "ğŸ‡µğŸ‡¸", rank: 133, continent: "AFC" },
        { name: "Kyrgyzstan", code: "KGZ", flag: "ğŸ‡°ğŸ‡¬", rank: 134, continent: "AFC" },
        { name: "Tajikistan", code: "TJK", flag: "ğŸ‡¹ğŸ‡¯", rank: 135, continent: "AFC" },
        { name: "Vietnam", code: "VIE", flag: "ğŸ‡»ğŸ‡³", rank: 136, continent: "AFC" },
        { name: "Thailand", code: "THA", flag: "ğŸ‡¹ğŸ‡­", rank: 137, continent: "AFC" },
        { name: "Indonesia", code: "IDN", flag: "ğŸ‡®ğŸ‡©", rank: 138, continent: "AFC" },
        { name: "India", code: "IND", flag: "ğŸ‡®ğŸ‡³", rank: 139, continent: "AFC" },
        { name: "Syria", code: "SYR", flag: "ğŸ‡¸ğŸ‡¾", rank: 140, continent: "AFC" },
        { name: "Lebanon", code: "LBN", flag: "ğŸ‡±ğŸ‡§", rank: 141, continent: "AFC" },
        { name: "Malaysia", code: "MAS", flag: "ğŸ‡²ğŸ‡¾", rank: 142, continent: "AFC" },
        { name: "Hong Kong", code: "HKG", flag: "ğŸ‡­ğŸ‡°", rank: 143, continent: "AFC" },

        // NORTH/CENTRAL AMERICA (CONCACAF) - 16 teams
        { name: "USA", code: "USA", flag: "ğŸ‡ºğŸ‡¸", rank: 15, continent: "CONCACAF" },
        { name: "Mexico", code: "MEX", flag: "ğŸ‡²ğŸ‡½", rank: 16, continent: "CONCACAF" },
        { name: "Panama", code: "PAN", flag: "ğŸ‡µğŸ‡¦", rank: 29, continent: "CONCACAF" },
        { name: "Honduras", code: "HON", flag: "ğŸ‡­ğŸ‡³", rank: 63, continent: "CONCACAF" },
        { name: "Canada", code: "CAN", flag: "ğŸ‡¨ğŸ‡¦", rank: 144, continent: "CONCACAF" },
        { name: "Costa Rica", code: "CRC", flag: "ğŸ‡¨ğŸ‡·", rank: 145, continent: "CONCACAF" },
        { name: "Jamaica", code: "JAM", flag: "ğŸ‡¯ğŸ‡²", rank: 146, continent: "CONCACAF" },
        { name: "El Salvador", code: "SLV", flag: "ğŸ‡¸ğŸ‡»", rank: 147, continent: "CONCACAF" },
        { name: "Curacao", code: "CUW", flag: "ğŸ‡¨ğŸ‡¼", rank: 148, continent: "CONCACAF" },
        { name: "Guatemala", code: "GUA", flag: "ğŸ‡¬ğŸ‡¹", rank: 149, continent: "CONCACAF" },
        { name: "Trinidad", code: "TRI", flag: "ğŸ‡¹ğŸ‡¹", rank: 150, continent: "CONCACAF" },
        { name: "Haiti", code: "HAI", flag: "ğŸ‡­ğŸ‡¹", rank: 151, continent: "CONCACAF" },
        { name: "Nicaragua", code: "NCA", flag: "ğŸ‡³ğŸ‡®", rank: 152, continent: "CONCACAF" },
        { name: "Suriname", code: "SUR", flag: "ğŸ‡¸ğŸ‡·", rank: 153, continent: "CONCACAF" },
        { name: "Dominica", code: "DMA", flag: "ğŸ‡©ğŸ‡²", rank: 154, continent: "CONCACAF" },
        { name: "Grenada", code: "GRN", flag: "ğŸ‡¬ğŸ‡©", rank: 155, continent: "CONCACAF" },
      ];

      const FMS = {
        "4-4-2": {
          d: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.15, y: 0.18, p: "LB" },
            { x: 0.38, y: 0.12, p: "CB" },
            { x: 0.62, y: 0.12, p: "CB" },
            { x: 0.85, y: 0.18, p: "RB" },
            { x: 0.20, y: 0.38, p: "LM" },
            { x: 0.37, y: 0.25, p: "CM" },
            { x: 0.63, y: 0.25, p: "CM" },
            { x: 0.80, y: 0.38, p: "RM" },
            { x: 0.30, y: 0.50, p: "ST" },
            { x: 0.70, y: 0.50, p: "ST" },
          ],
          a: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.15, y: 0.35, p: "LB" },
            { x: 0.38, y: 0.30, p: "CB" },
            { x: 0.62, y: 0.30, p: "CB" },
            { x: 0.85, y: 0.35, p: "RB" },
            { x: 0.1, y: 0.75, p: "LM" },
            { x: 0.35, y: 0.60, p: "CM" },
            { x: 0.65, y: 0.60, p: "CM" },
            { x: 0.9, y: 0.75, p: "RM" },
            { x: 0.25, y: 0.85, p: "ST" },
            { x: 0.75, y: 0.85, p: "ST" },
          ],
        },
        "4-3-3": {
          d: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.13, y: 0.18, p: "LB" },
            { x: 0.37, y: 0.12, p: "CB" },
            { x: 0.63, y: 0.12, p: "CB" },
            { x: 0.87, y: 0.18, p: "RB" },
            { x: 0.25, y: 0.25, p: "CM" },
            { x: 0.5, y: 0.22, p: "CM" },
            { x: 0.75, y: 0.25, p: "CM" },
            { x: 0.20, y: 0.44, p: "LW" },
            { x: 0.5, y: 0.50, p: "ST" },
            { x: 0.80, y: 0.44, p: "RW" },
          ],
          a: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.13, y: 0.35, p: "LB" },
            { x: 0.37, y: 0.30, p: "CB" },
            { x: 0.63, y: 0.30, p: "CB" },
            { x: 0.87, y: 0.35, p: "RB" },
            { x: 0.25, y: 0.60, p: "CM" },
            { x: 0.5, y: 0.55, p: "CM" },
            { x: 0.75, y: 0.60, p: "CM" },
            { x: 0.10, y: 0.82, p: "LW" },
            { x: 0.5, y: 0.85, p: "ST" },
            { x: 0.90, y: 0.82, p: "RW" },
          ],
        },
        "3-5-2": {
          d: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.25, y: 0.15, p: "CB" },
            { x: 0.5, y: 0.12, p: "CB" },
            { x: 0.75, y: 0.15, p: "CB" },
            { x: 0.08, y: 0.34, p: "LWB" },
            { x: 0.3, y: 0.32, p: "CM" },
            { x: 0.5, y: 0.28, p: "CDM" },
            { x: 0.7, y: 0.32, p: "CM" },
            { x: 0.92, y: 0.34, p: "RWB" },
            { x: 0.35, y: 0.52, p: "ST" },
            { x: 0.65, y: 0.52, p: "ST" },
          ],
          a: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.25, y: 0.30, p: "CB" },
            { x: 0.5, y: 0.27, p: "CB" },
            { x: 0.75, y: 0.30, p: "CB" },
            { x: 0.06, y: 0.60, p: "LWB" },
            { x: 0.28, y: 0.58, p: "CM" },
            { x: 0.5, y: 0.55, p: "CDM" },
            { x: 0.72, y: 0.58, p: "CM" },
            { x: 0.94, y: 0.60, p: "RWB" },
            { x: 0.35, y: 0.85, p: "ST" },
            { x: 0.65, y: 0.85, p: "ST" },
          ],
        },
        "4-2-3-1": {
          d: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.13, y: 0.18, p: "LB" },
            { x: 0.38, y: 0.15, p: "CB" },
            { x: 0.62, y: 0.15, p: "CB" },
            { x: 0.87, y: 0.18, p: "RB" },
            { x: 0.35, y: 0.30, p: "CDM" },
            { x: 0.65, y: 0.30, p: "CDM" },
            { x: 0.13, y: 0.44, p: "LW" },
            { x: 0.5, y: 0.42, p: "CAM" },
            { x: 0.87, y: 0.44, p: "RW" },
            { x: 0.5, y: 0.56, p: "ST" },
          ],
          a: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.13, y: 0.35, p: "LB" },
            { x: 0.38, y: 0.30, p: "CB" },
            { x: 0.62, y: 0.30, p: "CB" },
            { x: 0.87, y: 0.35, p: "RB" },
            { x: 0.35, y: 0.52, p: "CDM" },
            { x: 0.65, y: 0.52, p: "CDM" },
            { x: 0.12, y: 0.82, p: "LW" },
            { x: 0.5, y: 0.72, p: "CAM" },
            { x: 0.88, y: 0.82, p: "RW" },
            { x: 0.5, y: 0.85, p: "ST" },
          ],
        },
        "5-3-2": {
          d: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.08, y: 0.22, p: "LWB" },
            { x: 0.28, y: 0.15, p: "CB" },
            { x: 0.5, y: 0.12, p: "CB" },
            { x: 0.72, y: 0.15, p: "CB" },
            { x: 0.92, y: 0.22, p: "RWB" },
            { x: 0.25, y: 0.35, p: "CM" },
            { x: 0.5, y: 0.32, p: "CM" },
            { x: 0.75, y: 0.35, p: "CM" },
            { x: 0.35, y: 0.52, p: "ST" },
            { x: 0.65, y: 0.52, p: "ST" },
          ],
          a: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.06, y: 0.48, p: "LWB" },
            { x: 0.28, y: 0.30, p: "CB" },
            { x: 0.5, y: 0.27, p: "CB" },
            { x: 0.72, y: 0.30, p: "CB" },
            { x: 0.94, y: 0.48, p: "RWB" },
            { x: 0.25, y: 0.60, p: "CM" },
            { x: 0.5, y: 0.58, p: "CM" },
            { x: 0.75, y: 0.60, p: "CM" },
            { x: 0.35, y: 0.85, p: "ST" },
            { x: 0.65, y: 0.85, p: "ST" },
          ],
        },
        "4-1-4-1": {
          d: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.13, y: 0.18, p: "LB" },
            { x: 0.38, y: 0.15, p: "CB" },
            { x: 0.62, y: 0.15, p: "CB" },
            { x: 0.87, y: 0.18, p: "RB" },
            { x: 0.5, y: 0.28, p: "CDM" },
            { x: 0.1, y: 0.42, p: "LM" },
            { x: 0.37, y: 0.40, p: "CM" },
            { x: 0.63, y: 0.40, p: "CM" },
            { x: 0.9, y: 0.42, p: "RM" },
            { x: 0.5, y: 0.56, p: "ST" },
          ],
          a: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.13, y: 0.35, p: "LB" },
            { x: 0.38, y: 0.30, p: "CB" },
            { x: 0.62, y: 0.30, p: "CB" },
            { x: 0.87, y: 0.35, p: "RB" },
            { x: 0.5, y: 0.50, p: "CDM" },
            { x: 0.08, y: 0.73, p: "LM" },
            { x: 0.35, y: 0.65, p: "CM" },
            { x: 0.65, y: 0.65, p: "CM" },
            { x: 0.92, y: 0.73, p: "RM" },
            { x: 0.5, y: 0.85, p: "ST" },
          ],
        },
        "3-1-4-2": {
          d: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.25, y: 0.12, p: "CB" },
            { x: 0.5, y: 0.09, p: "CB" },
            { x: 0.75, y: 0.12, p: "CB" },
            { x: 0.5, y: 0.22, p: "CDM" },
            { x: 0.15, y: 0.35, p: "LM" },
            { x: 0.38, y: 0.30, p: "CM" },
            { x: 0.62, y: 0.30, p: "CM" },
            { x: 0.85, y: 0.35, p: "RM" },
            { x: 0.35, y: 0.48, p: "ST" },
            { x: 0.65, y: 0.48, p: "ST" },
          ],
          a: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.25, y: 0.28, p: "CB" },
            { x: 0.5, y: 0.25, p: "CB" },
            { x: 0.75, y: 0.28, p: "CB" },
            { x: 0.5, y: 0.45, p: "CDM" },
            { x: 0.12, y: 0.70, p: "LM" },
            { x: 0.35, y: 0.60, p: "CM" },
            { x: 0.65, y: 0.60, p: "CM" },
            { x: 0.88, y: 0.70, p: "RM" },
            { x: 0.30, y: 0.85, p: "ST" },
            { x: 0.70, y: 0.85, p: "ST" },
          ],
        },
        "3-2-3-2": {
          d: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.25, y: 0.12, p: "CB" },
            { x: 0.5, y: 0.09, p: "CB" },
            { x: 0.75, y: 0.12, p: "CB" },
            { x: 0.35, y: 0.24, p: "CDM" },
            { x: 0.65, y: 0.24, p: "CDM" },
            { x: 0.15, y: 0.42, p: "LM" },
            { x: 0.5, y: 0.38, p: "CAM" },
            { x: 0.85, y: 0.42, p: "RM" },
            { x: 0.35, y: 0.54, p: "ST" },
            { x: 0.65, y: 0.54, p: "ST" },
          ],
          a: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.25, y: 0.28, p: "CB" },
            { x: 0.5, y: 0.25, p: "CB" },
            { x: 0.75, y: 0.28, p: "CB" },
            { x: 0.35, y: 0.48, p: "CDM" },
            { x: 0.65, y: 0.48, p: "CDM" },
            { x: 0.12, y: 0.73, p: "LM" },
            { x: 0.5, y: 0.65, p: "CAM" },
            { x: 0.88, y: 0.73, p: "RM" },
            { x: 0.30, y: 0.85, p: "ST" },
            { x: 0.70, y: 0.85, p: "ST" },
          ],
        },
        "3-2-4-1": {
          d: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.25, y: 0.12, p: "CB" },
            { x: 0.5, y: 0.09, p: "CB" },
            { x: 0.75, y: 0.12, p: "CB" },
            { x: 0.35, y: 0.24, p: "CDM" },
            { x: 0.65, y: 0.24, p: "CDM" },
            { x: 0.1, y: 0.44, p: "LM" },
            { x: 0.35, y: 0.40, p: "CAM" },
            { x: 0.65, y: 0.40, p: "CAM" },
            { x: 0.9, y: 0.44, p: "RM" },
            { x: 0.5, y: 0.56, p: "CF" },
          ],
          a: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.25, y: 0.28, p: "CB" },
            { x: 0.5, y: 0.25, p: "CB" },
            { x: 0.75, y: 0.28, p: "CB" },
            { x: 0.35, y: 0.48, p: "CDM" },
            { x: 0.65, y: 0.48, p: "CDM" },
            { x: 0.08, y: 0.75, p: "LM" },
            { x: 0.32, y: 0.65, p: "CAM" },
            { x: 0.68, y: 0.65, p: "CAM" },
            { x: 0.92, y: 0.75, p: "RM" },
            { x: 0.5, y: 0.78, p: "CF" },
          ],
        },
        "3-4-1-2": {
          d: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.25, y: 0.12, p: "CB" },
            { x: 0.5, y: 0.09, p: "CB" },
            { x: 0.75, y: 0.12, p: "CB" },
            { x: 0.1, y: 0.30, p: "LM" },
            { x: 0.35, y: 0.24, p: "CM" },
            { x: 0.65, y: 0.24, p: "CM" },
            { x: 0.9, y: 0.30, p: "RM" },
            { x: 0.5, y: 0.40, p: "CAM" },
            { x: 0.35, y: 0.52, p: "ST" },
            { x: 0.65, y: 0.52, p: "ST" },
          ],
          a: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.25, y: 0.28, p: "CB" },
            { x: 0.5, y: 0.25, p: "CB" },
            { x: 0.75, y: 0.28, p: "CB" },
            { x: 0.08, y: 0.68, p: "LM" },
            { x: 0.32, y: 0.52, p: "CM" },
            { x: 0.68, y: 0.52, p: "CM" },
            { x: 0.92, y: 0.63, p: "RM" },
            { x: 0.5, y: 0.70, p: "CAM" },
            { x: 0.30, y: 0.85, p: "ST" },
            { x: 0.70, y: 0.85, p: "ST" },
          ],
        },
        "3-4-2-1": {
          d: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.25, y: 0.12, p: "CB" },
            { x: 0.5, y: 0.09, p: "CB" },
            { x: 0.75, y: 0.12, p: "CB" },
            { x: 0.1, y: 0.32, p: "LM" },
            { x: 0.37, y: 0.26, p: "CM" },
            { x: 0.63, y: 0.26, p: "CM" },
            { x: 0.9, y: 0.32, p: "RM" },
            { x: 0.25, y: 0.46, p: "LF" },
            { x: 0.75, y: 0.46, p: "RF" },
            { x: 0.5, y: 0.56, p: "ST" },
          ],
          a: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.25, y: 0.28, p: "CB" },
            { x: 0.5, y: 0.25, p: "CB" },
            { x: 0.75, y: 0.28, p: "CB" },
            { x: 0.08, y: 0.70, p: "LM" },
            { x: 0.35, y: 0.55, p: "CM" },
            { x: 0.65, y: 0.55, p: "CM" },
            { x: 0.92, y: 0.65, p: "RM" },
            { x: 0.25, y: 0.82, p: "LF" },
            { x: 0.75, y: 0.82, p: "RF" },
            { x: 0.5, y: 0.85, p: "ST" },
          ],
        },
        "3-4-3": {
          d: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.25, y: 0.12, p: "CB" },
            { x: 0.5, y: 0.09, p: "CB" },
            { x: 0.75, y: 0.12, p: "CB" },
            { x: 0.1, y: 0.32, p: "LM" },
            { x: 0.37, y: 0.26, p: "CM" },
            { x: 0.63, y: 0.26, p: "CM" },
            { x: 0.9, y: 0.32, p: "RM" },
            { x: 0.2, y: 0.48, p: "LW" },
            { x: 0.5, y: 0.50, p: "ST" },
            { x: 0.8, y: 0.48, p: "RW" },
          ],
          a: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.25, y: 0.28, p: "CB" },
            { x: 0.5, y: 0.25, p: "CB" },
            { x: 0.75, y: 0.28, p: "CB" },
            { x: 0.08, y: 0.70, p: "LM" },
            { x: 0.35, y: 0.55, p: "CM" },
            { x: 0.65, y: 0.55, p: "CM" },
            { x: 0.92, y: 0.65, p: "RM" },
            { x: 0.12, y: 0.82, p: "LW" },
            { x: 0.5, y: 0.85, p: "ST" },
            { x: 0.88, y: 0.82, p: "RW" },
          ],
        },
        "3-5-1-1": {
          d: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.25, y: 0.12, p: "CB" },
            { x: 0.5, y: 0.09, p: "CB" },
            { x: 0.75, y: 0.12, p: "CB" },
            { x: 0.08, y: 0.30, p: "LM" },
            { x: 0.3, y: 0.26, p: "CDM" },
            { x: 0.5, y: 0.24, p: "CM" },
            { x: 0.7, y: 0.26, p: "CDM" },
            { x: 0.92, y: 0.30, p: "RM" },
            { x: 0.5, y: 0.42, p: "CF" },
            { x: 0.5, y: 0.54, p: "ST" },
          ],
          a: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.25, y: 0.28, p: "CB" },
            { x: 0.5, y: 0.25, p: "CB" },
            { x: 0.75, y: 0.28, p: "CB" },
            { x: 0.06, y: 0.68, p: "LM" },
            { x: 0.28, y: 0.52, p: "CDM" },
            { x: 0.5, y: 0.50, p: "CM" },
            { x: 0.72, y: 0.52, p: "CDM" },
            { x: 0.94, y: 0.63, p: "RM" },
            { x: 0.5, y: 0.78, p: "CF" },
            { x: 0.5, y: 0.85, p: "ST" },
          ],
        },
        "4-1-2-1-2": {
          d: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.13, y: 0.18, p: "LB" },
            { x: 0.38, y: 0.15, p: "CB" },
            { x: 0.62, y: 0.15, p: "CB" },
            { x: 0.87, y: 0.18, p: "RB" },
            { x: 0.5, y: 0.28, p: "CDM" },
            { x: 0.35, y: 0.40, p: "CM" },
            { x: 0.65, y: 0.40, p: "CM" },
            { x: 0.5, y: 0.48, p: "CAM" },
            { x: 0.35, y: 0.56, p: "ST" },
            { x: 0.65, y: 0.56, p: "ST" },
          ],
          a: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.13, y: 0.35, p: "LB" },
            { x: 0.38, y: 0.30, p: "CB" },
            { x: 0.62, y: 0.30, p: "CB" },
            { x: 0.87, y: 0.35, p: "RB" },
            { x: 0.5, y: 0.50, p: "CDM" },
            { x: 0.32, y: 0.62, p: "CM" },
            { x: 0.68, y: 0.62, p: "CM" },
            { x: 0.5, y: 0.72, p: "CAM" },
            { x: 0.30, y: 0.85, p: "ST" },
            { x: 0.70, y: 0.85, p: "ST" },
          ],
        },
        "4-1-2-3": {
          d: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.13, y: 0.18, p: "LB" },
            { x: 0.38, y: 0.15, p: "CB" },
            { x: 0.62, y: 0.15, p: "CB" },
            { x: 0.87, y: 0.18, p: "RB" },
            { x: 0.5, y: 0.28, p: "CDM" },
            { x: 0.35, y: 0.38, p: "CM" },
            { x: 0.65, y: 0.38, p: "CM" },
            { x: 0.2, y: 0.50, p: "LW" },
            { x: 0.5, y: 0.52, p: "ST" },
            { x: 0.8, y: 0.50, p: "RW" },
          ],
          a: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.13, y: 0.35, p: "LB" },
            { x: 0.38, y: 0.30, p: "CB" },
            { x: 0.62, y: 0.30, p: "CB" },
            { x: 0.87, y: 0.35, p: "RB" },
            { x: 0.5, y: 0.50, p: "CDM" },
            { x: 0.32, y: 0.62, p: "CM" },
            { x: 0.68, y: 0.62, p: "CM" },
            { x: 0.12, y: 0.82, p: "LW" },
            { x: 0.5, y: 0.85, p: "ST" },
            { x: 0.88, y: 0.82, p: "RW" },
          ],
        },
        "4-1-3-2": {
          d: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.13, y: 0.18, p: "LB" },
            { x: 0.38, y: 0.15, p: "CB" },
            { x: 0.62, y: 0.15, p: "CB" },
            { x: 0.87, y: 0.18, p: "RB" },
            { x: 0.5, y: 0.28, p: "CDM" },
            { x: 0.2, y: 0.40, p: "LM" },
            { x: 0.5, y: 0.38, p: "CM" },
            { x: 0.8, y: 0.40, p: "RM" },
            { x: 0.35, y: 0.52, p: "ST" },
            { x: 0.65, y: 0.52, p: "ST" },
          ],
          a: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.13, y: 0.35, p: "LB" },
            { x: 0.38, y: 0.30, p: "CB" },
            { x: 0.62, y: 0.30, p: "CB" },
            { x: 0.87, y: 0.35, p: "RB" },
            { x: 0.5, y: 0.50, p: "CDM" },
            { x: 0.15, y: 0.70, p: "LM" },
            { x: 0.5, y: 0.62, p: "CM" },
            { x: 0.85, y: 0.70, p: "RM" },
            { x: 0.30, y: 0.85, p: "ST" },
            { x: 0.70, y: 0.85, p: "ST" },
          ],
        },
        "4-2-2-2": {
          d: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.13, y: 0.18, p: "LB" },
            { x: 0.38, y: 0.15, p: "CB" },
            { x: 0.62, y: 0.15, p: "CB" },
            { x: 0.87, y: 0.18, p: "RB" },
            { x: 0.35, y: 0.28, p: "CDM" },
            { x: 0.65, y: 0.28, p: "CDM" },
            { x: 0.28, y: 0.44, p: "CAM" },
            { x: 0.72, y: 0.44, p: "CAM" },
            { x: 0.35, y: 0.56, p: "ST" },
            { x: 0.65, y: 0.56, p: "ST" },
          ],
          a: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.13, y: 0.35, p: "LB" },
            { x: 0.38, y: 0.30, p: "CB" },
            { x: 0.62, y: 0.30, p: "CB" },
            { x: 0.87, y: 0.35, p: "RB" },
            { x: 0.35, y: 0.50, p: "CDM" },
            { x: 0.65, y: 0.50, p: "CDM" },
            { x: 0.25, y: 0.70, p: "CAM" },
            { x: 0.75, y: 0.70, p: "CAM" },
            { x: 0.30, y: 0.85, p: "ST" },
            { x: 0.70, y: 0.85, p: "ST" },
          ],
        },
        "4-2-3-1": {
          d: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.13, y: 0.18, p: "LB" },
            { x: 0.38, y: 0.15, p: "CB" },
            { x: 0.62, y: 0.15, p: "CB" },
            { x: 0.87, y: 0.18, p: "RB" },
            { x: 0.35, y: 0.28, p: "CDM" },
            { x: 0.65, y: 0.28, p: "CDM" },
            { x: 0.2, y: 0.44, p: "CAM" },
            { x: 0.5, y: 0.42, p: "CAM" },
            { x: 0.8, y: 0.44, p: "CAM" },
            { x: 0.5, y: 0.56, p: "ST" },
          ],
          a: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.13, y: 0.35, p: "LB" },
            { x: 0.38, y: 0.30, p: "CB" },
            { x: 0.62, y: 0.30, p: "CB" },
            { x: 0.87, y: 0.35, p: "RB" },
            { x: 0.35, y: 0.50, p: "CDM" },
            { x: 0.65, y: 0.50, p: "CDM" },
            { x: 0.15, y: 0.72, p: "CAM" },
            { x: 0.5, y: 0.70, p: "CAM" },
            { x: 0.85, y: 0.72, p: "CAM" },
            { x: 0.5, y: 0.85, p: "ST" },
          ],
        },
        "4-2-4": {
          d: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.13, y: 0.18, p: "LB" },
            { x: 0.38, y: 0.15, p: "CB" },
            { x: 0.62, y: 0.15, p: "CB" },
            { x: 0.87, y: 0.18, p: "RB" },
            { x: 0.35, y: 0.28, p: "CM" },
            { x: 0.65, y: 0.28, p: "CM" },
            { x: 0.15, y: 0.46, p: "LW" },
            { x: 0.38, y: 0.50, p: "ST" },
            { x: 0.62, y: 0.50, p: "ST" },
            { x: 0.85, y: 0.46, p: "RW" },
          ],
          a: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.13, y: 0.35, p: "LB" },
            { x: 0.38, y: 0.30, p: "CB" },
            { x: 0.62, y: 0.30, p: "CB" },
            { x: 0.87, y: 0.35, p: "RB" },
            { x: 0.35, y: 0.52, p: "CM" },
            { x: 0.65, y: 0.52, p: "CM" },
            { x: 0.12, y: 0.82, p: "LW" },
            { x: 0.35, y: 0.85, p: "ST" },
            { x: 0.65, y: 0.85, p: "ST" },
            { x: 0.88, y: 0.82, p: "RW" },
          ],
        },
        "4-3-1-2": {
          d: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.13, y: 0.18, p: "LB" },
            { x: 0.38, y: 0.15, p: "CB" },
            { x: 0.62, y: 0.15, p: "CB" },
            { x: 0.87, y: 0.18, p: "RB" },
            { x: 0.25, y: 0.30, p: "CM" },
            { x: 0.5, y: 0.28, p: "CM" },
            { x: 0.75, y: 0.30, p: "CM" },
            { x: 0.5, y: 0.44, p: "CAM" },
            { x: 0.35, y: 0.56, p: "ST" },
            { x: 0.65, y: 0.56, p: "ST" },
          ],
          a: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.13, y: 0.35, p: "LB" },
            { x: 0.38, y: 0.30, p: "CB" },
            { x: 0.62, y: 0.30, p: "CB" },
            { x: 0.87, y: 0.35, p: "RB" },
            { x: 0.22, y: 0.58, p: "CM" },
            { x: 0.5, y: 0.55, p: "CM" },
            { x: 0.78, y: 0.58, p: "CM" },
            { x: 0.5, y: 0.72, p: "CAM" },
            { x: 0.30, y: 0.85, p: "ST" },
            { x: 0.70, y: 0.85, p: "ST" },
          ],
        },
        "4-3-2-1": {
          d: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.13, y: 0.18, p: "LB" },
            { x: 0.38, y: 0.15, p: "CB" },
            { x: 0.62, y: 0.15, p: "CB" },
            { x: 0.87, y: 0.18, p: "RB" },
            { x: 0.25, y: 0.30, p: "CM" },
            { x: 0.5, y: 0.28, p: "CM" },
            { x: 0.75, y: 0.30, p: "CM" },
            { x: 0.3, y: 0.48, p: "LF" },
            { x: 0.7, y: 0.48, p: "RF" },
            { x: 0.5, y: 0.58, p: "ST" },
          ],
          a: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.13, y: 0.35, p: "LB" },
            { x: 0.38, y: 0.30, p: "CB" },
            { x: 0.62, y: 0.30, p: "CB" },
            { x: 0.87, y: 0.35, p: "RB" },
            { x: 0.22, y: 0.58, p: "CM" },
            { x: 0.5, y: 0.55, p: "CM" },
            { x: 0.78, y: 0.58, p: "CM" },
            { x: 0.25, y: 0.82, p: "LF" },
            { x: 0.75, y: 0.82, p: "RF" },
            { x: 0.5, y: 0.85, p: "ST" },
          ],
        },
        "4-4-1-1": {
          d: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.13, y: 0.18, p: "LB" },
            { x: 0.38, y: 0.15, p: "CB" },
            { x: 0.62, y: 0.15, p: "CB" },
            { x: 0.87, y: 0.18, p: "RB" },
            { x: 0.15, y: 0.38, p: "LM" },
            { x: 0.38, y: 0.32, p: "CM" },
            { x: 0.62, y: 0.32, p: "CM" },
            { x: 0.85, y: 0.38, p: "RM" },
            { x: 0.5, y: 0.48, p: "CF" },
            { x: 0.5, y: 0.58, p: "ST" },
          ],
          a: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.13, y: 0.35, p: "LB" },
            { x: 0.38, y: 0.30, p: "CB" },
            { x: 0.62, y: 0.30, p: "CB" },
            { x: 0.87, y: 0.35, p: "RB" },
            { x: 0.12, y: 0.70, p: "LM" },
            { x: 0.35, y: 0.58, p: "CM" },
            { x: 0.65, y: 0.58, p: "CM" },
            { x: 0.88, y: 0.70, p: "RM" },
            { x: 0.5, y: 0.78, p: "CF" },
            { x: 0.5, y: 0.85, p: "ST" },
          ],
        },
        "4-5-1": {
          d: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.13, y: 0.18, p: "LB" },
            { x: 0.38, y: 0.15, p: "CB" },
            { x: 0.62, y: 0.15, p: "CB" },
            { x: 0.87, y: 0.18, p: "RB" },
            { x: 0.1, y: 0.38, p: "LM" },
            { x: 0.35, y: 0.32, p: "CM" },
            { x: 0.5, y: 0.30, p: "CDM" },
            { x: 0.65, y: 0.32, p: "CM" },
            { x: 0.9, y: 0.38, p: "RM" },
            { x: 0.5, y: 0.56, p: "ST" },
          ],
          a: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.13, y: 0.35, p: "LB" },
            { x: 0.38, y: 0.30, p: "CB" },
            { x: 0.62, y: 0.30, p: "CB" },
            { x: 0.87, y: 0.35, p: "RB" },
            { x: 0.08, y: 0.73, p: "LM" },
            { x: 0.32, y: 0.60, p: "CM" },
            { x: 0.5, y: 0.58, p: "CDM" },
            { x: 0.68, y: 0.60, p: "CM" },
            { x: 0.92, y: 0.73, p: "RM" },
            { x: 0.5, y: 0.85, p: "ST" },
          ],
        },
        "5-2-1-2": {
          d: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.08, y: 0.22, p: "LWB" },
            { x: 0.28, y: 0.15, p: "CB" },
            { x: 0.5, y: 0.12, p: "CB" },
            { x: 0.72, y: 0.15, p: "CB" },
            { x: 0.92, y: 0.22, p: "RWB" },
            { x: 0.35, y: 0.32, p: "CM" },
            { x: 0.65, y: 0.32, p: "CM" },
            { x: 0.5, y: 0.45, p: "CAM" },
            { x: 0.35, y: 0.56, p: "ST" },
            { x: 0.65, y: 0.56, p: "ST" },
          ],
          a: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.06, y: 0.48, p: "LWB" },
            { x: 0.28, y: 0.30, p: "CB" },
            { x: 0.5, y: 0.27, p: "CB" },
            { x: 0.72, y: 0.30, p: "CB" },
            { x: 0.94, y: 0.48, p: "RWB" },
            { x: 0.32, y: 0.62, p: "CM" },
            { x: 0.68, y: 0.62, p: "CM" },
            { x: 0.5, y: 0.72, p: "CAM" },
            { x: 0.30, y: 0.85, p: "ST" },
            { x: 0.70, y: 0.85, p: "ST" },
          ],
        },
        "5-2-2-1": {
          d: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.08, y: 0.22, p: "LWB" },
            { x: 0.28, y: 0.15, p: "CB" },
            { x: 0.5, y: 0.12, p: "CB" },
            { x: 0.72, y: 0.15, p: "CB" },
            { x: 0.92, y: 0.22, p: "RWB" },
            { x: 0.35, y: 0.32, p: "CM" },
            { x: 0.65, y: 0.32, p: "CM" },
            { x: 0.25, y: 0.48, p: "LW" },
            { x: 0.75, y: 0.48, p: "RW" },
            { x: 0.5, y: 0.58, p: "ST" },
          ],
          a: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.06, y: 0.48, p: "LWB" },
            { x: 0.28, y: 0.30, p: "CB" },
            { x: 0.5, y: 0.27, p: "CB" },
            { x: 0.72, y: 0.30, p: "CB" },
            { x: 0.94, y: 0.48, p: "RWB" },
            { x: 0.32, y: 0.62, p: "CM" },
            { x: 0.68, y: 0.62, p: "CM" },
            { x: 0.18, y: 0.82, p: "LW" },
            { x: 0.82, y: 0.82, p: "RW" },
            { x: 0.5, y: 0.85, p: "ST" },
          ],
        },
        "5-2-3": {
          d: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.08, y: 0.22, p: "LWB" },
            { x: 0.28, y: 0.15, p: "CB" },
            { x: 0.5, y: 0.12, p: "CB" },
            { x: 0.72, y: 0.15, p: "CB" },
            { x: 0.92, y: 0.22, p: "RWB" },
            { x: 0.35, y: 0.32, p: "CM" },
            { x: 0.65, y: 0.32, p: "CM" },
            { x: 0.20, y: 0.52, p: "LW" },
            { x: 0.5, y: 0.54, p: "ST" },
            { x: 0.80, y: 0.52, p: "RW" },
          ],
          a: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.06, y: 0.48, p: "LWB" },
            { x: 0.28, y: 0.30, p: "CB" },
            { x: 0.5, y: 0.27, p: "CB" },
            { x: 0.72, y: 0.30, p: "CB" },
            { x: 0.94, y: 0.48, p: "RWB" },
            { x: 0.32, y: 0.62, p: "CM" },
            { x: 0.68, y: 0.62, p: "CM" },
            { x: 0.12, y: 0.82, p: "LW" },
            { x: 0.5, y: 0.85, p: "ST" },
            { x: 0.88, y: 0.82, p: "RW" },
          ],
        },
        "5-4-1": {
          d: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.08, y: 0.22, p: "LWB" },
            { x: 0.28, y: 0.15, p: "CB" },
            { x: 0.5, y: 0.12, p: "CB" },
            { x: 0.72, y: 0.15, p: "CB" },
            { x: 0.92, y: 0.22, p: "RWB" },
            { x: 0.15, y: 0.38, p: "LM" },
            { x: 0.38, y: 0.34, p: "CM" },
            { x: 0.62, y: 0.34, p: "CM" },
            { x: 0.85, y: 0.38, p: "RM" },
            { x: 0.5, y: 0.56, p: "ST" },
          ],
          a: [
            { x: 0.5, y: 0.04, p: "GK" },
            { x: 0.06, y: 0.48, p: "LWB" },
            { x: 0.28, y: 0.30, p: "CB" },
            { x: 0.5, y: 0.27, p: "CB" },
            { x: 0.72, y: 0.30, p: "CB" },
            { x: 0.94, y: 0.48, p: "RWB" },
            { x: 0.12, y: 0.73, p: "LM" },
            { x: 0.35, y: 0.62, p: "CM" },
            { x: 0.65, y: 0.62, p: "CM" },
            { x: 0.88, y: 0.73, p: "RM" },
            { x: 0.5, y: 0.85, p: "ST" },
          ],
        },
      };

      const LN = [
        "Silva",
        "Kim",
        "Park",
        "Mohamed",
        "Ali",
        "Santos",
        "LÃ³pez",
        "MÃ¼ller",
        "Petrov",
        "Tanaka",
        "Hassan",
        "Ahmed",
        "Diallo",
        "TourÃ©",
        "Nakamura",
        "Lee",
        "Chen",
        "Okafor",
        "Ndiaye",
        "HernÃ¡ndez",
        "Johansson",
        "Eriksen",
        "Nielsen",
        "Popov",
        "Ivanov",
        "Novak",
        "HorvÃ¡th",
        "KovÃ¡cs",
        "Rossi",
        "Schmidt",
        "GarcÃ­a",
        "FernÃ¡ndez",
        "GonzÃ¡lez",
        "RodrÃ­guez",
        "MartÃ­nez",
        "SÃ¡nchez",
      ];
      function gNames() {
        const n = [];
        const u = new Set();
        for (let i = 0; i < 11; i++) {
          let s;
          do {
            s = LN[Math.floor(Math.random() * LN.length)];
          } while (u.has(s) && u.size < LN.length);
          u.add(s);
          n.push(s);
        }
        return n;
      }

      const C = document.getElementById("gameCanvas"),
        X = C.getContext("2d");
      
      // Enable crisp text rendering
      X.imageSmoothingEnabled = true;
      X.imageSmoothingQuality = 'high';
      X.textRendering = 'optimizeLegibility'; // Better text
      
      let G = {
        mode: "menu",
        state: "menu",
        turn: "home",
        hs: 0,
        as: 0,
        ht: null,
        at: null,
        hf: "4-3-3",
        af: "4-4-2",
        pl: { home: [], away: [] },
        ball: { x: 0, y: 0.00, r: 5 },
        sel: null,
        ds: null,
        dc: null,
        fw: 0,
        fh: 0,
        fx: 0,
        fy: 0.00,
        gw: 0,
        gh: 0,
        anims: [],
        // mg: 5, // REMOVED - No more goal limit
        matchTime: 0, // Current match time (0-90 game minutes)
        matchDuration: 90, // Match duration in game minutes
        matchStartTime: null, // Timestamp when match started
        goldenGoalMode: false, // Golden goal (knockout draws)
        matchTimerSpeed: 90 / 240, // 90 game minutes in 240 real seconds (4 minutes)
        cup: null,
        step: "home",
        poss: "home",
        lastK: null,
        passesAfterWin: 0,
        ballWinner: null, // Ki szerezte meg a labdÃ¡t
        useMySquad: false, // Use user's custom squad instead of country team
        
        // PLAYER DATABASE & USER PROGRESSION
        playersDB: [], // 2079 players from JSON
        userSquad: {
          players: [], // Player IDs (max 23)
          formation: '4-3-3',
          coins: 0,
          level: 1,
          xp: 0,
          nextLevelXP: 1000
        },
        userCollection: new Set(), // All owned player IDs
      };
      const FR = 1.5;

      function resize() {
        const c = document.getElementById("gameContainer"),
          sb = document.getElementById("scoreboard");
        
        // HiDPI/Retina support - scale canvas for crisp graphics
        const dpr = window.devicePixelRatio || 1;
        const displayWidth = c.clientWidth;
        const displayHeight = c.clientHeight - (sb.classList.contains("active") ? 50 : 0);
        
        // Set canvas size in memory (scaled by device pixel ratio)
        C.width = displayWidth * dpr;
        C.height = displayHeight * dpr;
        
        // Set display size (CSS pixels)
        C.style.width = displayWidth + 'px';
        C.style.height = displayHeight + 'px';
        
        // Reset transform and scale by dpr for sharp rendering
        X.setTransform(1, 0, 0, 1, 0, 0); // Reset
        X.scale(dpr, dpr); // Scale for HiDPI
        
        // Now calculate field dimensions using DISPLAY pixels
        const p = 10,
          aW = displayWidth - p * 2,
          aH = displayHeight - p * 2;
        if (aH / aW > FR) {
          G.fw = aW;
          G.fh = G.fw * FR;
        } else {
          G.fh = aH;
          G.fw = G.fh / FR;
        }
        G.fx = (displayWidth - G.fw) / 2;
        G.fy = (displayHeight - G.fh) / 2;
        G.gw = G.fw * 0.26;
        G.gh = G.fh * 0.035;
        G.ball.r = Math.max(4, G.fw * 0.013);
      }

      function initP() {
        // Check if we should use user's custom squad
        if (G.useMySquad && G.playersDB.length > 0) {
          initUserSquad();
          return;
        }
        
        // Load both teams from national squads (database)
        ["home", "away"].forEach((t) => {
          let fm = t === "home" ? G.hf : G.af;
          
          // Default fallback
          if (!fm) fm = '4-4-2';
          
          let fd = FMS[fm];
          
          // Fallback if formation not found
          if (!fd) {
            console.error(`Formation ${fm} not found in FMS! Using 4-4-2 fallback.`);
            fd = FMS['4-4-2'];
            fm = '4-4-2';
          }
          
          const ps = G.poss === t ? fd.a : fd.d;
          
          // Try to load national squad from database
          const teamCode = t === "home" ? G.ht.code : G.at.code;
          const nationalSquad = teamCode ? generateNationalSquad(teamCode, fm) : null;
          
          G.pl[t] = ps.map((pp, i) => {
            let fx, fy;
            if (t === "home") {
              fx = G.fx + pp.x * G.fw;
              fy = G.fy + G.fh - pp.y * G.fh;
            } else {
              fx = G.fx + (1 - pp.x) * G.fw;
              fy = G.fy + pp.y * G.fh;
            }
            
            // Get player from national squad if exists
            const player = nationalSquad && nationalSquad[i] ? nationalSquad[i] : null;
            
            return {
              id: `${t}_${i}`,
              team: t,
              name: player ? player.name : gNames()[i],
              position: pp.p,
              bx: fx,
              by: fy,
              x: fx,
              y: fy,
              r: Math.max(9, G.fw * 0.025),
              hb: false,
              num: i === 0 ? 1 : i + 1,
              // MozgÃ¡s vÃ¡ltozÃ³k
              moveTargetX: fx,
              moveTargetY: fy,
              moveTimer: Math.random() * 2000, // Random kezdÃ©s
              moveState: 'rest', // 'moving' vagy 'rest'
              
              // Player stats from database or generic
              playerData: player,
              speed: player ? player.speed : 70,
              shooting: player ? player.shooting : 70,
              passing: player ? player.passing : 70,
              defense: player ? player.defense || player.tackling : 70,
              marking: player ? player.marking : 70,
              positioning: player ? player.positioning : 70,
              reflex: player ? player.reflex || player.reflexes : 70,
              finishing: player ? player.finishing : 70,
              longShot: player ? player.longShot : 70,
              kicking: player ? player.kicking : 70,
            };
          });
        });
        G.ball.x = G.fx + G.fw / 2;
        G.ball.y = G.fy + G.fh / 2;
        
        // KICKOFF: Ensure someone gets the ball (ignore defense radius for kickoff)
        let closestPlayer = null;
        let minDist = Infinity;
        
        G.pl[G.turn].forEach((p) => {
          const d = Math.hypot(p.x - G.ball.x, p.y - G.ball.y);
          if (d < minDist) {
            minDist = d;
            closestPlayer = p;
          }
        });
        
        if (closestPlayer) {
          G.pl.home.forEach((p) => (p.hb = false));
          G.pl.away.forEach((p) => (p.hb = false));
          closestPlayer.hb = true;
          closestPlayer.moveState = 'rest';
          G.ball.x = closestPlayer.x;
          G.ball.y = closestPlayer.y;
          G.sel = closestPlayer;
        }
      }
      
      // Load user's custom squad into match
      function initUserSquad() {
        const formation = G.hf || '4-4-2'; // Default if not set
        let fd = FMS[formation];
        
        // Fallback if formation not found
        if (!fd) {
          console.error(`Formation ${formation} not found in FMS! Using 4-4-2 fallback.`);
          fd = FMS['4-4-2'];
        }
        
        const ps = G.poss === "home" ? fd.a : fd.d;
        
        // Load home team from user's squad
        G.pl.home = ps.map((pp, i) => {
          // Get player from squad (if exists)
          const playerId = G.userSquad.players[i];
          const player = playerId ? getPlayerById(playerId) : null;
          
          let fx = G.fx + pp.x * G.fw;
          let fy = G.fy + G.fh - pp.y * G.fh;
          
          return {
            id: `home_${i}`,
            team: 'home',
            name: player ? player.name : '???',
            position: pp.p,
            bx: fx,
            by: fy,
            x: fx,
            y: fy,
            r: Math.max(9, G.fw * 0.025),
            hb: false,
            num: i === 0 ? 1 : i + 1,
            moveTargetX: fx,
            moveTargetY: fy,
            moveTimer: Math.random() * 2000,
            moveState: 'rest',
            
            // PLAYER STATS (from database)
            playerData: player, // Full player object
            speed: player ? player.speed : 70,
            shooting: player ? player.shooting : 70,
            passing: player ? player.passing : 70,
            defense: player ? player.defense || player.tackling : 70,
            marking: player ? player.marking : 70,
            positioning: player ? player.positioning : 70,
            reflex: player ? player.reflex || player.reflexes : 70,
            finishing: player ? player.finishing : 70,
            longShot: player ? player.longShot : 70,
            kicking: player ? player.kicking : 70,
          };
        });
        
        // Away team from national database
        const awayFm = G.af || '4-4-2'; // Default if not set
        let awayFd = FMS[awayFm];
        
        // Fallback if formation not found
        if (!awayFd) {
          console.error(`Formation ${awayFm} not found in FMS! Using 4-4-2 fallback.`);
          awayFd = FMS['4-4-2'];
        }
        
        const awayPs = G.poss === "away" ? awayFd.a : awayFd.d;
        
        // Try to load away team from database
        const awaySquad = G.at ? generateNationalSquad(G.at.code, awayFm) : null;
        
        G.pl.away = awayPs.map((pp, i) => {
          let fx = G.fx + (1 - pp.x) * G.fw;
          let fy = G.fy + pp.y * G.fh;
          
          // Get player from national squad if exists
          const player = awaySquad && awaySquad[i] ? awaySquad[i] : null;
          
          return {
            id: `away_${i}`,
            team: 'away',
            name: player ? player.name : gNames()[i],
            position: pp.p,
            bx: fx,
            by: fy,
            x: fx,
            y: fy,
            r: Math.max(9, G.fw * 0.025),
            hb: false,
            num: i === 0 ? 1 : i + 1,
            moveTargetX: fx,
            moveTargetY: fy,
            moveTimer: Math.random() * 2000,
            moveState: 'rest',
            
            // Player stats from database or generic
            playerData: player,
            speed: player ? player.speed : 70,
            shooting: player ? player.shooting : 70,
            passing: player ? player.passing : 70,
            defense: player ? player.defense || player.tackling : 70,
            marking: player ? player.marking : 70,
            positioning: player ? player.positioning : 70,
            reflex: player ? player.reflex || player.reflexes : 70,
            finishing: player ? player.finishing : 70,
            longShot: player ? player.longShot : 70,
            kicking: player ? player.kicking : 70,
          };
        });
        
        G.ball.x = G.fx + G.fw / 2;
        G.ball.y = G.fy + G.fh / 2;
        
        // KICKOFF: Ensure someone gets the ball (ignore defense radius for kickoff)
        let closestPlayer = null;
        let minDist = Infinity;
        
        G.pl[G.turn].forEach((p) => {
          const d = Math.hypot(p.x - G.ball.x, p.y - G.ball.y);
          if (d < minDist) {
            minDist = d;
            closestPlayer = p;
          }
        });
        
        if (closestPlayer) {
          G.pl.home.forEach((p) => (p.hb = false));
          G.pl.away.forEach((p) => (p.hb = false));
          closestPlayer.hb = true;
          closestPlayer.moveState = 'rest';
          G.ball.x = closestPlayer.x;
          G.ball.y = closestPlayer.y;
          G.sel = closestPlayer;
        }
      }
      
      function abn(t) {
        let md = 1e9,
          cl = null;
        G.pl[t].forEach((p) => {
          // DEFENSE RADIUS based on defense stat
          const baseRadius = p.r;
          const defenseBonus = (p.defense || 50) / 100; // 0.5-1.0x based on defense (50-100)
          const defenseRadius = baseRadius + (G.fw * 0.05 * defenseBonus); // 5-10% of field width
          
          const d = Math.hypot(p.x - G.ball.x, p.y - G.ball.y);
          
          // Check if player can intercept (within defense radius)
          if (d <= defenseRadius && d < md) {
            md = d;
            cl = p;
          }
        });
        
        // FALLBACK: If nobody within defense radius, give to closest player anyway
        if (!cl) {
          let closestDist = Infinity;
          G.pl[t].forEach((p) => {
            const d = Math.hypot(p.x - G.ball.x, p.y - G.ball.y);
            if (d < closestDist) {
              closestDist = d;
              cl = p;
            }
          });
        }
        
        if (cl) {
          G.pl.home.forEach((p) => (p.hb = false));
          G.pl.away.forEach((p) => (p.hb = false));
          cl.hb = true;
          
          // KRITIKUS: NE Ã¡llÃ­tsuk Ã¡t a bx,by-t!
          // A jÃ¡tÃ©kos maradjon ahol van, ne ugorjon vissza
          // cl.bx = cl.x;  â† TÃ–RÃ–LVE
          // cl.by = cl.y;  â† TÃ–RÃ–LVE
          
          cl.moveState = 'rest'; // MegÃ¡llÃ­tjuk a mozgÃ¡st
          
          // Labda a jÃ¡tÃ©koshoz
          G.ball.x = cl.x;
          G.ball.y = cl.y;
          G.sel = cl;
        }
      }

      function adjustPositions(team) {
        const minDist = 30;
        const players = G.pl[team];
        for (let i = 0; i < players.length; i++)
          for (let j = i + 1; j < players.length; j++) {
            const p1 = players[i],
              p2 = players[j],
              dx = p1.x - p2.x,
              dy = p1.y - p2.y,
              dist = Math.hypot(dx, dy);
            if (dist < minDist) {
              const overlap = minDist - dist,
                nx = dx / dist,
                ny = dy / dist;
              p1.x += (nx * overlap) / 2;
              p1.y += (ny * overlap) / 2;
              p2.x -= (nx * overlap) / 2;
              p2.y -= (ny * overlap) / 2;
              p1.bx = p1.x;
              p1.by = p1.y;
              p2.bx = p2.x;
              p2.by = p2.y;
            }
          }
      }

      function updFP(anim = true) {
        ["home", "away"].forEach((t) => {
          let fm = t === "home" ? G.hf : G.af;
          
          // Default fallback
          if (!fm) fm = '4-4-2';
          
          let fd = FMS[fm];
          
          // Fallback if formation not found
          if (!fd) {
            console.error(`updFP: Formation ${fm} not found in FMS! Using 4-4-2 fallback.`);
            fd = FMS['4-4-2'];
            fm = '4-4-2';
          }
          
          const ps = G.poss === t ? fd.a : fd.d;
          G.pl[t].forEach((p, i) => {
            if (p.hb) return;
            
            // CSAK a labdÃ¡t szerzÅ‘ jÃ¡tÃ©kos marad vÃ©dekezÅ‘ben 1 passzig
            if (G.ballWinner && p.id === G.ballWinner.id && G.passesAfterWin < 1) {
              return;
            }
            
            const pp = ps[i];
            let fx, fy;
            if (t === "home") {
              fx = G.fx + pp.x * G.fw;
              fy = G.fy + G.fh - pp.y * G.fh;
            } else {
              fx = G.fx + (1 - pp.x) * G.fw;
              fy = G.fy + pp.y * G.fh;
            }
            
            // CAP attacking positions - don't let them get too close to GK
            // New unified values: LW/RW: 0.82, ST: 0.85, CF: 0.78
            // With breathing (~5.5%), max becomes: LW/RW: ~0.875, ST: ~0.905, CF: ~0.835
            const isAttacking = G.poss === t;
            const isAttackingPosition = ['LW', 'ST', 'CF', 'RW', 'LF', 'RF'].includes(p.position);
            
            if (isAttacking && isAttackingPosition) {
              // No CAP needed anymore - positions are already safe (0.78-0.85)
              // Even with breathing (+5.5%), max is ~0.905 which is acceptable
            }
            
            // MARKING SYSTEM - Defenders mark ball carrier when opponent has ball
            const isDefender = ['CB', 'LB', 'RB', 'LWB', 'RWB'].includes(p.position);
            const opponentHasBall = G.poss !== t;
            
            if (isDefender && opponentHasBall) {
              // Find which attacker to mark based on position
              const opponentTeam = t === 'home' ? G.pl.away : G.pl.home;
              const ballCarrier = opponentTeam.find(opp => opp.hb);
              
              if (ballCarrier) {
                // ONLY mark the ball carrier (not all attackers!)
                let targetAttacker = null;
                
                // Check if ball carrier is in defender's zone
                const ballCarrierPosition = ballCarrier.position;
                const shouldMark = 
                  (p.position === 'CB' && ['ST', 'CF', 'CAM'].includes(ballCarrierPosition)) ||
                  ((p.position === 'LB' || p.position === 'LWB') && ['RW', 'RM'].includes(ballCarrierPosition)) ||
                  ((p.position === 'RB' || p.position === 'RWB') && ['LW', 'LM'].includes(ballCarrierPosition));
                
                if (shouldMark) {
                  targetAttacker = ballCarrier; // Mark the ball carrier
                  
                  // INTELLIGENT MARKING: Only closest defender marks
                  // Check if this defender is the closest to the ball carrier
                  const myDist = Math.hypot(p.x - ballCarrier.x, p.y - ballCarrier.y);
                  
                  // Find all defenders of same type who could mark this ball carrier
                  const competingDefenders = G.pl[t].filter(d => 
                    d.id !== p.id && 
                    ['CB', 'LB', 'RB', 'LWB', 'RWB'].includes(d.position)
                  );
                  
                  // Check if any other defender is closer
                  const isClosest = !competingDefenders.some(d => {
                    const theirDist = Math.hypot(d.x - ballCarrier.x, d.y - ballCarrier.y);
                    return theirDist < myDist;
                  });
                  
                  // Only mark if I'm the closest defender
                  if (!isClosest) {
                    targetAttacker = null; // Don't mark - let closer defender do it
                  }
                }
                
                // If target found and close enough (within marking radius)
                if (targetAttacker) {
                  const markingRadius = G.fw * 0.30; // 30% of field width
                  const distToAttacker = Math.hypot(p.x - targetAttacker.x, p.y - targetAttacker.y);
                  
                  if (distToAttacker < markingRadius) {
                    // BLOCKING POSITION calculation
                    // Position between attacker and goal to block shooting angle
                    const goalX = t === 'home' ? G.fx + G.fw / 2 : G.fx + G.fw / 2;
                    const goalY = t === 'home' ? G.fy + G.fh : G.fy;
                    
                    // Vector from attacker to goal
                    const toGoalX = goalX - targetAttacker.x;
                    const toGoalY = goalY - targetAttacker.y;
                    const toGoalDist = Math.hypot(toGoalX, toGoalY);
                    
                    if (toGoalDist > 0) {
                      // MARKING STAT - better marking = closer to attacker, better angle
                      const markingStat = p.marking || 70;
                      const markingQuality = markingStat / 100; // 0.5-1.0
                      
                      // Position: X% of the way from attacker to goal
                      // High marking = 30-40% (closer), Low marking = 50-60% (further)
                      const blockDistance = 0.60 - (markingQuality * 0.20); // 0.40-0.60
                      
                      const blockX = targetAttacker.x + (toGoalX / toGoalDist) * (toGoalDist * blockDistance);
                      const blockY = targetAttacker.y + (toGoalY / toGoalDist) * (toGoalDist * blockDistance);
                      
                      // Override formation position with blocking position
                      fx = blockX;
                      fy = blockY;
                    }
                  }
                }
              }
            }
            
            // BeÃ¡llÃ­tjuk a CÃ‰L pozÃ­ciÃ³t (targetBx, targetBy)
            // Az updatePlayerMovement majd lassan odaviszi a bx,by-t
            if (anim) {
              p.targetBx = fx;
              p.targetBy = fy;
            } else {
              // Ha nincs animÃ¡ciÃ³, azonnal oda tesszÃ¼k
              p.bx = fx;
              p.by = fy;
              p.x = fx;
              p.y = fy;
            }
          });
        });
      }

      // Drawing
      function dF() {
        const { fx, fy, fw, fh } = G;
        
        // SÃ¶tÃ©tebb, realisztikusabb zÃ¶ld
        X.fillStyle = "#1a6b1a";
        X.fillRect(fx, fy, fw, fh);
        
        // CsÃ­kok (stripes) - sÃ¶tÃ©tebb Ã©s vilÃ¡gosabb
        for (let i = 0; i < 14; i++) {
          if (i % 2 === 0) {
            X.fillStyle = "rgba(0,0,0,.04)";
            X.fillRect(fx, fy + (fh / 14) * i, fw, fh / 14);
          }
        }
        
        // FehÃ©r vonalak - vastagabb Ã©s vilÃ¡gosabb
        X.strokeStyle = "rgba(255,255,255,.8)";
        X.lineWidth = 2;
        X.strokeRect(fx, fy, fw, fh);
        
        // KÃ¶zÃ©pvonal
        X.beginPath();
        X.moveTo(fx, fy + fh / 2);
        X.lineTo(fx + fw, fy + fh / 2);
        X.stroke();
        
        // KÃ¶zÃ©pkÃ¶r
        X.beginPath();
        X.arc(fx + fw / 2, fy + fh / 2, fw * 0.1, 0, Math.PI * 2);
        X.stroke();
        
        // KÃ¶zÃ©ppont
        X.fillStyle = "rgba(255,255,255,.9)";
        X.beginPath();
        X.arc(fx + fw / 2, fy + fh / 2, 3, 0, Math.PI * 2);
        X.fill();
        
        // Kapuk Ã©s 16-osok
        const gaW = fw * 0.44,
          gaH = fh * 0.065,
          paW = fw * 0.64,
          paH = fh * 0.13;
        X.strokeRect(fx + (fw - paW) / 2, fy, paW, paH);
        X.strokeRect(fx + (fw - gaW) / 2, fy, gaW, gaH);
        X.strokeRect(fx + (fw - paW) / 2, fy + fh - paH, paW, paH);
        X.strokeRect(fx + (fw - gaW) / 2, fy + fh - gaH, gaW, gaH);
        
        // BÃ¼ntetÅ‘pontok
        X.fillStyle = "rgba(255,255,255,.9)";
        X.beginPath();
        X.arc(fx + fw / 2, fy + fh * 0.1, 2.5, 0, Math.PI * 2);
        X.fill();
        X.beginPath();
        X.arc(fx + fw / 2, fy + fh * 0.9, 2.5, 0, Math.PI * 2);
        X.fill();
        
        // BÃ¼ntetÅ‘Ã­v felsÅ‘
        X.beginPath();
        X.arc(
          fx + fw / 2,
          fy + fh * 0.1,
          fw * 0.08,
          0.2 * Math.PI,
          0.8 * Math.PI,
        );
        X.stroke();
        
        // BÃ¼ntetÅ‘Ã­v alsÃ³
        X.beginPath();
        X.arc(
          fx + fw / 2,
          fy + fh * 0.9,
          fw * 0.08,
          1.2 * Math.PI,
          1.8 * Math.PI,
        );
        X.stroke();
        const gw = G.gw;
        dGN(fx + (fw - gw) / 2, fy - G.gh, gw, G.gh, "#60a5fa");
        dGN(fx + (fw - gw) / 2, fy + fh, gw, G.gh, "#f87171");
      }
      function dGN(x, y, w, h, c) {
        X.fillStyle = c + "20";
        X.fillRect(x, y, w, h);
        X.strokeStyle = c;
        X.lineWidth = 2;
        X.strokeRect(x, y, w, h);
        X.strokeStyle = c + "25";
        X.lineWidth = 0.4;
        for (let i = x; i <= x + w; i += 5) {
          X.beginPath();
          X.moveTo(i, y);
          X.lineTo(i, y + h);
          X.stroke();
        }
        for (let j = y; j <= y + h; j += 5) {
          X.beginPath();
          X.moveTo(x, j);
          X.lineTo(x + w, j);
          X.stroke();
        }
      }

      function dP() {
        [...G.pl.home, ...G.pl.away].forEach((p) => {
          const ih = p.team === "home",
            is = G.sel && G.sel.id === p.id,
            ic = p.team === G.turn;
          
          // ÃrnyÃ©k - nagyobb Ã©s lÃ¡gyabb
          X.fillStyle = "rgba(0,0,0,.3)";
          X.beginPath();
          X.ellipse(p.x + 1, p.y + 3, p.r * 1.1, p.r * 0.6, 0, 0, Math.PI * 2);
          X.fill();
          
          // JÃ¡tÃ©kos szÃ­nek - Ã©lÃ©nkebb
          const mc = ih ? "#1d4ed8" : "#dc2626", // SÃ¶tÃ©tebb kÃ©k/piros
            lc = ih ? "#60a5fa" : "#f87171",      // VilÃ¡gosabb kÃ©k/piros
            hc = ih ? "#bfdbfe" : "#fecaca";      // Highlight szÃ­n
          
          // 3D gradient effekt
          const gr = X.createRadialGradient(p.x - p.r * 0.3, p.y - p.r * 0.3, 1, p.x, p.y, p.r);
          gr.addColorStop(0, hc);
          gr.addColorStop(0.4, lc);
          gr.addColorStop(1, mc);
          
          X.fillStyle = gr;
          X.beginPath();
          X.arc(p.x, p.y, p.r, 0, Math.PI * 2);
          X.fill();
          
          // KÃ¼lsÅ‘ kÃ¶r (outline)
          X.strokeStyle = is
            ? "#facc15"
            : ic
              ? "rgba(255,255,255,.7)"
              : "rgba(255,255,255,.3)";
          X.lineWidth = is ? 3 : 1.5;
          X.stroke();
          
          // KijelÃ¶lt jÃ¡tÃ©kos extra effekt
          if (is && G.state === "playing") {
            X.strokeStyle = "#facc1570";
            X.lineWidth = 2;
            X.beginPath();
            X.arc(p.x, p.y, p.r + 5, 0, Math.PI * 2);
            X.stroke();
            
            // PulzÃ¡lÃ³ effekt
            const pulse = Math.sin(Date.now() / 200) * 0.3 + 0.7;
            X.strokeStyle = `rgba(250, 204, 21, ${pulse * 0.4})`;
            X.lineWidth = 1.5;
            X.beginPath();
            X.arc(p.x, p.y, p.r + 8, 0, Math.PI * 2);
            X.stroke();
          }
          
          // LabdÃ¡t birtoklÃ³ jÃ¡tÃ©kos jelzÃ©s
          if (p.hb) {
            X.strokeStyle = "#facc15";
            X.lineWidth = 2;
            X.setLineDash([4, 4]);
            X.beginPath();
            X.arc(p.x, p.y, p.r + 7, 0, Math.PI * 2);
            X.stroke();
            X.setLineDash([]);
          }
          
          // SzÃ¡m a jÃ¡tÃ©koson - Ã¡rnyÃ©kkal
          X.fillStyle = "rgba(0,0,0,.4)";
          X.font = `bold ${Math.max(8, p.r * 0.7)}px 'Barlow Condensed',sans-serif`;
          X.textAlign = "center";
          X.textBaseline = "middle";
          X.fillText(p.num, p.x + 0.5, p.y + 0.5);
          
          X.fillStyle = "#fff";
          X.fillText(p.num, p.x, p.y);
          
          // PozÃ­ciÃ³ nÃ©v - Ã¡rnyÃ©kkal
          X.fillStyle = "rgba(0,0,0,.5)";
          X.font = `bold ${Math.max(6, p.r * 0.45)}px 'Barlow Condensed',sans-serif`;
          X.fillText(p.position, p.x + 0.5, p.y + p.r + 7.5);
          
          X.fillStyle = "rgba(255,255,255,.85)";
          X.fillText(p.position, p.x, p.y + p.r + 7);
        });
      }

      function dB() {
        const b = G.ball;
        
        // ÃrnyÃ©k - nagyobb Ã©s lÃ¡gyabb
        X.fillStyle = "rgba(0,0,0,.35)";
        X.beginPath();
        X.ellipse(b.x + 1, b.y + 2, b.r * 1.2, b.r * 0.6, 0, 0, Math.PI * 2);
        X.fill();
        
        // Labda fehÃ©r alapszÃ­n - 3D gradient
        const gr = X.createRadialGradient(b.x - b.r * 0.3, b.y - b.r * 0.3, 1, b.x, b.y, b.r);
        gr.addColorStop(0, "#ffffff");
        gr.addColorStop(0.7, "#f0f0f0");
        gr.addColorStop(1, "#d0d0d0");
        
        X.fillStyle = gr;
        X.beginPath();
        X.arc(b.x, b.y, b.r, 0, Math.PI * 2);
        X.fill();
        
        // Fekete Ã¶tszÃ¶gek (egyszerÅ±sÃ­tett focilabda minta)
        X.fillStyle = "#1a1a1a";
        
        // FelsÅ‘ Ã¶tszÃ¶g
        X.beginPath();
        for (let i = 0; i < 5; i++) {
          const angle = (i * 2 * Math.PI) / 5 - Math.PI / 2;
          const x = b.x + Math.cos(angle) * b.r * 0.4;
          const y = b.y - b.r * 0.5 + Math.sin(angle) * b.r * 0.4;
          if (i === 0) X.moveTo(x, y);
          else X.lineTo(x, y);
        }
        X.closePath();
        X.fill();
        
        // Bal oldal Ã¶tszÃ¶g
        X.beginPath();
        for (let i = 0; i < 5; i++) {
          const angle = (i * 2 * Math.PI) / 5 + Math.PI / 6;
          const x = b.x - b.r * 0.5 + Math.cos(angle) * b.r * 0.35;
          const y = b.y + Math.sin(angle) * b.r * 0.35;
          if (i === 0) X.moveTo(x, y);
          else X.lineTo(x, y);
        }
        X.closePath();
        X.fill();
        
        // Jobb oldal Ã¶tszÃ¶g
        X.beginPath();
        for (let i = 0; i < 5; i++) {
          const angle = (i * 2 * Math.PI) / 5 - Math.PI / 6;
          const x = b.x + b.r * 0.5 + Math.cos(angle) * b.r * 0.35;
          const y = b.y + Math.sin(angle) * b.r * 0.35;
          if (i === 0) X.moveTo(x, y);
          else X.lineTo(x, y);
        }
        X.closePath();
        X.fill();
        
        // Highlight a tetejÃ©n (fÃ©ny effekt)
        const hlgr = X.createRadialGradient(b.x - b.r * 0.3, b.y - b.r * 0.3, 0, b.x - b.r * 0.3, b.y - b.r * 0.3, b.r * 0.5);
        hlgr.addColorStop(0, "rgba(255,255,255,.6)");
        hlgr.addColorStop(1, "rgba(255,255,255,0)");
        X.fillStyle = hlgr;
        X.beginPath();
        X.arc(b.x, b.y, b.r, 0, Math.PI * 2);
        X.fill();
      }

      function fPT(sh, dx, dy, md) {
        const ms = G.pl[sh.team].filter((p) => p.id !== sh.id);
        let best = null,
          bd = 1e9;
        ms.forEach((t) => {
          const tdx = t.x - sh.x,
            tdy = t.y - sh.y,
            td = Math.hypot(tdx, tdy);
          if (td > md * 1.5 || td < 10) return;
          const dot = (tdx * dx + tdy * dy) / td;
          if (dot > 0.8) {
            const perp = Math.abs(-dy * tdx + dx * tdy);
            if (perp < t.r * 3.5 && td < bd) {
              bd = td;
              best = t;
            }
          }
        });
        return best;
      }

      function dAL() {
        if (!G.ds || !G.dc || !G.sel) return;
        const p = G.sel,
          dx = G.ds.x - G.dc.x,
          dy = G.ds.y - G.dc.y,
          len = Math.hypot(dx, dy);
        if (len < 8) return;
        const pw = Math.min(len / 150, 1),
          dix = dx / len,
          diy = dy / len,
          al = pw * G.fw * 0.35 * 0.75; // 25%-kal kisebb csÃºzli
        const ex = p.x + dix * al,
          ey = p.y + diy * al;
        
        // DINAMIKUS TÃPUS MEGHATÃROZÃS: lÃ¶vÃ©s vagy passzolÃ¡s?
        const md = pw * G.fw * 0.75;
        const potentialTarget = fPT(p, dix, diy, md);
        const actionType = potentialTarget ? "pass" : "shoot"; // Ha van target â†’ passz, kÃ¼lÃ¶nben â†’ lÃ¶vÃ©s
        
        // PONTOSSÃG a megfelelÅ‘ tÃ­pussal + power
        let acc = gAcc(p, al, actionType, pw); // Stats handle all accuracy
        
        const sp = (1 - acc) * 0.55; // HibahatÃ¡r szÃ¶ge
        
        // HIBAHATÃR HÃROMSZÃ–G - ÃšJ SZÃNSÃ‰MA
        if (actionType === "pass") {
          // PASSZ: FEHÃ‰R
          X.fillStyle = "rgba(255,255,255,0.2)";
          X.strokeStyle = "rgba(255,255,255,0.6)";
        } else {
          // LÃ–VÃ‰S: ZÃ–LD (base)
          X.fillStyle = "rgba(34,197,94,0.25)";
          X.strokeStyle = "rgba(34,197,94,0.6)";
        }
        
        // Alap hÃ¡romszÃ¶g (teljes)
        X.beginPath();
        X.moveTo(p.x, p.y);
        X.lineTo(
          p.x + Math.cos(Math.atan2(diy, dix) - sp) * al,
          p.y + Math.sin(Math.atan2(diy, dix) - sp) * al,
        );
        X.lineTo(
          p.x + Math.cos(Math.atan2(diy, dix) + sp) * al,
          p.y + Math.sin(Math.atan2(diy, dix) + sp) * al,
        );
        X.closePath();
        X.fill();
        
        // KÃ–RVONAL
        X.lineWidth = 2;
        X.stroke();
        
        // KÃ‰K RÃ‰SZ ha lÃ¶vÃ©s Ã‰S â‰¥75% power (Long Shot zone)
        if (actionType === "shoot" && pw >= 0.75) {
          // SzÃ¡moljuk ki hol van a 75% pont a csÃºzlin
          const al75 = 0.75 * G.fw * 0.35 * 0.75; // 75% csÃºzli hossz
          const alFull = al; // Teljes csÃºzli hossz
          
          // KÃ‰K hÃ¡romszÃ¶g a 75%-tÃ³l a vÃ©gÃ©ig
          X.fillStyle = "rgba(59,130,246,0.3)"; // KÃ©k, Ã¡tlÃ¡tszÃ³
          X.strokeStyle = "rgba(59,130,246,0.7)"; // KÃ©k kÃ¶rvonal
          
          X.beginPath();
          // 75% pont a kÃ¶zÃ©pvonalban
          const mid75X = p.x + dix * al75;
          const mid75Y = p.y + diy * al75;
          
          // Bal oldal (75% pontbÃ³l a bal csÃºcsig)
          const leftEndX = p.x + Math.cos(Math.atan2(diy, dix) - sp) * alFull;
          const leftEndY = p.y + Math.sin(Math.atan2(diy, dix) - sp) * alFull;
          const left75X = p.x + Math.cos(Math.atan2(diy, dix) - sp) * al75;
          const left75Y = p.y + Math.sin(Math.atan2(diy, dix) - sp) * al75;
          
          // Jobb oldal (75% pontbÃ³l a jobb csÃºcsig)
          const rightEndX = p.x + Math.cos(Math.atan2(diy, dix) + sp) * alFull;
          const rightEndY = p.y + Math.sin(Math.atan2(diy, dix) + sp) * alFull;
          const right75X = p.x + Math.cos(Math.atan2(diy, dix) + sp) * al75;
          const right75Y = p.y + Math.sin(Math.atan2(diy, dix) + sp) * al75;
          
          // Rajzoljuk a kÃ©k trapÃ©zt (75%-tÃ³l a vÃ©gÃ©ig)
          X.moveTo(left75X, left75Y);
          X.lineTo(leftEndX, leftEndY);
          X.lineTo(rightEndX, rightEndY);
          X.lineTo(right75X, right75Y);
          X.closePath();
          X.fill();
          X.stroke();
        }
        
        // SZAGGATOTT VONAL (irÃ¡ny)
        X.strokeStyle = `rgba(250,204,21,${0.4 + pw * 0.5})`;
        X.lineWidth = 1.5;
        X.setLineDash([4, 3]);
        X.beginPath();
        X.moveTo(p.x, p.y);
        X.lineTo(ex, ey);
        X.stroke();
        X.setLineDash([]);
        
        // NYÃL HEGYE (sÃ¡rga)
        const ha = 7,
          an = Math.atan2(diy, dix);
        X.fillStyle = "#facc15";
        X.beginPath();
        X.moveTo(ex, ey);
        X.lineTo(ex - ha * Math.cos(an - 0.4), ey - ha * Math.sin(an - 0.4));
        X.lineTo(ex - ha * Math.cos(an + 0.4), ey - ha * Math.sin(an + 0.4));
        X.closePath();
        X.fill();
        
        // ERÅ MÃ‰RÅ
        const pb = document.getElementById("pb"),
          pf = document.getElementById("pf");
        pb.style.display = "block";
        pf.style.width = pw * 100 + "%";
        pf.style.background = `rgb(${Math.round(255 * pw)},${Math.round(255 * (1 - pw))},40)`;
        
        // PASSZ TARGET JELZÃ‰S (zÃ¶ld kÃ¶r)
        if (potentialTarget) {
          X.strokeStyle = "#22c55e";
          X.lineWidth = 2;
          X.beginPath();
          X.arc(potentialTarget.x, potentialTarget.y, potentialTarget.r + 5, 0, Math.PI * 2);
          X.stroke();
        }
      }

      // Mechanics
      function gAcc(p, d, type, power = 0) {
        // type = "pass" vagy "shoot"
        // power = shot/pass power (0-1)
        
        // TÃ¡volsÃ¡g alapÃº alap pontossÃ¡g
        const maxDist = G.fh * 0.8;
        let baseAcc = 1 - (d / maxDist) * 0.85;
        baseAcc = Math.max(0.08, Math.min(0.85, baseAcc)); // 8-85%
        
        // POZÃCIÃ“ ALAPÃš MÃ“DOSÃTÃ“K TÃ–RÃ–LVE
        // Stats handle everything now (attackers have high shooting, etc.)
        let modifier = 1.0;
        
        // ===== PLAYER STATS INTEGRATION - UNIFIED KICKING (SHOOTING/PASSING) =====
        
        // 1. KICKING STAT (unified for all positions, GK uses "kicking" instead)
        let kickingStat = 70; // Default
        
        if (p.position === 'GK') {
          kickingStat = p.kicking || 70; // GK uses "kicking" stat
        } else if (type === "shoot") {
          kickingStat = p.shooting || 70; // Outfield shooting
        } else {
          kickingStat = p.passing || 70; // Outfield passing
        }
        
        // 2. ERROR MARGIN based on stat (99 = 0% error, 50 = max error)
        // Formula: errorFactor = (100 - stat) / 100
        // 99 stat â†’ 1% error, 70 stat â†’ 30% error, 50 stat â†’ 50% error
        const errorFactor = (100 - kickingStat) / 100; // 0.01 (99 stat) to 0.50 (50 stat)
        
        // 3. BASE ACCURACY affected by error (inverse of error)
        const statAccuracy = 1 - (errorFactor * 0.5); // 0.75-1.0 range (50%-25% error)
        modifier *= statAccuracy;
        
        // 4. LONG SHOT ACCURACY BONUS (midfielders, power > 75%)
        if (type === "shoot" && power > 0.75) {
          const isMidfielder = ['CM', 'CDM', 'CAM', 'LM', 'RM'].includes(p.position);
          
          if (isMidfielder && p.longShot) {
            // Formula: +0.10% accuracy per 1 stat point
            // 70 long shot â†’ +7% accuracy, 99 long shot â†’ +9.9% accuracy
            const longShotBonus = (p.longShot * 0.001); // 0-0.10
            modifier *= (1 + longShotBonus); // Add as multiplier
          }
        }
        
        // 5. REMOVE position-based modifier (already handled by stats)
        // Attackers have high shooting, midfielders high passing, etc.
        
        // Alkalmazzuk a mÃ³dosÃ­tÃ³t
        let finalAcc = baseAcc * modifier;
        
        // VÃ©gsÅ‘ hatÃ¡rok: 5-95%
        return Math.max(0.05, Math.min(0.95, finalAcc));
      }
      function aIn(tx, ty, sx, sy, a) {
        const d = Math.hypot(tx - sx, ty - sy),
          mo = d * (1 - a) * 0.55; // NÃ–VELVE 0.35 â†’ 0.55 (nagyobb szÃ³rÃ¡s)
        return {
          x: tx + (Math.random() - 0.5) * 2 * mo,
          y: ty + (Math.random() - 0.5) * 2 * mo,
        };
      }

      function kick(pl, dx, dy, pw) {
        if (G.state !== "playing") return;
        
        // Ha a ballWinner passzol, csak nullÃ¡zzuk (ne Ã¡llÃ­tsuk vissza hirtelen)
        // Az updFP folyamatosan fut a hÃ¡ttÃ©rben, Ã­gy smooth lesz az Ã¡tmenet
        if (G.ballWinner && pl.id === G.ballWinner.id) {
          G.ballWinner = null;
        }
        
        const sp = pw * G.fh * 0.04,
          md = pw * G.fw * 0.75;
        const pt = fPT(pl, dx, dy, md);
        let tx, ty, kt;
        G.lastK = pl;
        G.passesAfterWin++;
        
        // EXTRA BIZTONSÃG: Reset animÃ¡ciÃ³ Ã¡llapot rÃºgÃ¡skor
        // Ãgy biztosan nem lesz "instant jump" ha kÃ¶zben mozgott volna
        pl.moveState = 'rest';
        pl.moveStartTime = Date.now();
        pl.moveTargetX = undefined;
        pl.moveTargetY = undefined;
        
        // EXTRA KRITIKUS: Reset targetBx/targetBy is!
        pl.targetBx = undefined;
        pl.targetBy = undefined;
        pl.bx = pl.x;
        pl.by = pl.y;
        
        if (pt) {
          kt = "pass";
          let a = gAcc(pl, Math.hypot(pt.x - pl.x, pt.y - pl.y), "pass", pw);
          
          // Stats handle passing accuracy now (no position-based penalty)
          
          const r = aIn(pt.x, pt.y, pl.x, pl.y, a);
          tx = r.x;
          ty = r.y;
        } else {
          kt = "shoot";
          tx = pl.x + dx * md;
          ty = pl.y + dy * md;
          const d = Math.hypot(tx - pl.x, ty - pl.y),
            a = gAcc(pl, d, "shoot", pw), // Pass power
            r = aIn(tx, ty, pl.x, pl.y, a);
          tx = r.x;
          ty = r.y;
        }
        G.state = "anim";
        pl.hb = false;
        const td = Math.hypot(tx - pl.x, ty - pl.y),
          dur = Math.max(200, (td / sp) * 16);
        anBall(pl.x, pl.y, tx, ty, dur, kt, pt, pw); // ADD pw parameter
      }

      function anBall(sx, sy, ex, ey, dur, kt, pt, pw) { // ADD pw parameter
        const st = performance.now();
        function s(n) {
          let t = Math.min((n - st) / dur, 1);
          t = 1 - (1 - t) * (1 - t);
          G.ball.x = sx + (ex - sx) * t;
          G.ball.y = sy + (ey - sy) * t;
          if (cGoal()) return;
          
          // CHECK OUT OF BOUNDS - if ball goes out, opponent gets it immediately
          let outOfBounds = false;
          if (G.ball.x < G.fx || G.ball.x > G.fx + G.fw) {
            outOfBounds = true;
            G.ball.x = Math.max(G.fx, Math.min(G.ball.x, G.fx + G.fw));
          }
          if (G.ball.y < G.fy - G.gh || G.ball.y > G.fy + G.fh + G.gh) {
            outOfBounds = true;
            G.ball.y = Math.max(G.fy, Math.min(G.ball.y, G.fy + G.fh));
          }
          
          if (outOfBounds) {
            // Ball went out of bounds - opponent gets it
            const op = G.turn === "home" ? "away" : "home";
            G.turn = op;
            G.poss = op;
            fTurn(); // Assign to nearest opponent
            return;
          }
          
          const op = G.turn === "home" ? "away" : "home";
          let ic = false;
          G.pl[op].forEach((o) => {
            if (ic) return;
            const d = Math.hypot(o.x - G.ball.x, o.y - G.ball.y);
            
            // INTERCEPTION RADIUS based on defense stat (for outfield) or fixed for GK
            let interceptionRadius = o.r + G.ball.r + 2; // Base
            
            if (o.position === 'GK') {
              // GK has larger interception radius
              interceptionRadius = o.r + G.ball.r + (G.fw * 0.08); // 8% of field width
            } else {
              // Outfield players use defense stat
              const defenseStat = o.defense || 50;
              const defenseBonus = defenseStat / 100; // 0.5-1.0
              interceptionRadius = o.r + G.ball.r + (G.fw * 0.03 * defenseBonus); // 1.5-3% of field width
            }
            
            if (d < interceptionRadius) {
              let ch = 0.40; // Default interception chance (40%)
              
              // GK SAVE SYSTEM (REFLEX + POSITIONING)
              if (o.position === "GK" && kt === "shoot") {
                // Calculate shot position relative to goal
                const goalLeft = G.fx + (G.fw - G.gw) / 2;
                const goalWidth = G.gw;
                const shotRelativeX = (G.ball.x - goalLeft) / goalWidth; // 0-1 (0=left, 1=right)
                
                let saveChance = 0.50; // Base 50%
                
                // ZONE DETECTION
                if (shotRelativeX <= 0.20 || shotRelativeX >= 0.80) {
                  // REFLEX ZONE (0-20% or 80-100% of goal)
                  // Formula: reflex stat - 10 = save %
                  // 50 reflex â†’ 40%, 99 reflex â†’ 89%
                  const reflexStat = o.reflex || 70;
                  saveChance = (reflexStat - 10) / 100; // 0.40-0.89
                } else {
                  // POSITIONING ZONE (21-79% of goal - center)
                  // Formula: 50 + (positioning * 0.5) = save %
                  // 50 positioning â†’ 75%, 99 positioning â†’ 99.5%
                  const positioningStat = o.positioning || 70;
                  saveChance = (50 + (positioningStat * 0.5)) / 100; // 0.75-0.995
                }
                
                // WEAK SHOT BONUS (power < 75%)
                // Get shooter info from last kick
                const shooter = G.sel; // Player who kicked
                const shotPower = pw; // Power of shot (0-1)
                
                if (shotPower < 0.75) {
                  // Weak shot: +20% save chance base
                  let weakShotBonus = 0.20;
                  
                  // FINISHING STAT (attackers only)
                  // Formula: -0.20% per 1 stat point
                  // 50 finishing â†’ -10% (net +10%), 99 finishing â†’ -19.8% (net ~0%)
                  if (shooter && shooter.finishing) {
                    const finishingReduction = (shooter.finishing * 0.002); // 0-0.20
                    weakShotBonus -= finishingReduction;
                  }
                  
                  saveChance += Math.max(0, weakShotBonus); // Add bonus (can be 0 if high finishing)
                }
                
                // LONG SHOT STAT (power > 75%, midfielders only)
                if (shotPower > 0.75 && shooter) {
                  const isMidfielder = ['CM', 'CDM', 'CAM', 'LM', 'RM'].includes(shooter.position);
                  
                  if (isMidfielder && shooter.longShot) {
                    // Formula: -0.10% error per 1 stat point
                    // This reduces GK save chance for powerful shots
                    // 70 long shot â†’ -7% GK save, 99 long shot â†’ -9.9% GK save
                    const longShotReduction = (shooter.longShot * 0.001); // 0-0.10
                    saveChance -= longShotReduction;
                  }
                }
                
                // GK NERF: -15% save chance (too strong otherwise)
                saveChance -= 0.15;
                
                // Clamp to reasonable range
                saveChance = Math.max(0.05, Math.min(0.95, saveChance));
                ch = saveChance;
              } else if (o.position === "GK") {
                // GK interception for passes (not shots)
                ch = 0.60; // Higher for passes
              } else {
                // DEFENSE STAT for outfield players (interception)
                const defenseStat = o.defense || 50;
                // 50 defense â†’ 40%, 90 defense â†’ 60%
                ch = 0.20 + (defenseStat / 100) * 0.50; // 0.20-0.70 range
              }
              
              if (Math.random() < ch) {
                ic = true;
                G.pl.home.forEach((p) => (p.hb = false));
                G.pl.away.forEach((p) => (p.hb = false));
                o.hb = true;
                G.ball.x = o.x;
                G.ball.y = o.y;
                G.sel = o;
                G.turn = op;
                G.poss = op;
                G.passesAfterWin = 0;
                G.ballWinner = o; // BeÃ¡llÃ­tjuk ki szerezte meg
                
                // KRITIKUS: Reset mozgÃ¡s Ã¡llapot hogy ne legyen "instant jump" rÃºgÃ¡s utÃ¡n
                o.moveState = 'rest';
                o.moveStartTime = Date.now();
                o.moveTargetX = undefined;
                o.moveTargetY = undefined;
                
                // EXTRA KRITIKUS: Reset targetBx/targetBy is!
                // Ãgy nem folytatja a tÃ¡madÃ³ pozÃ­ciÃ³ba menetelt labdavesztÃ©s utÃ¡n
                o.targetBx = undefined;
                o.targetBy = undefined;
                // Jelenlegi pozÃ­ciÃ³ = base pozÃ­ciÃ³
                o.bx = o.x;
                o.by = o.y;
                
                G.state = "playing";
                updFP();
                uUI();
              }
            }
          });
          if (ic) return;
          if (pt && t > 0.35) {
            const d = Math.hypot(pt.x - G.ball.x, pt.y - G.ball.y);
            if (d < pt.r + G.ball.r + 6) {
              G.pl.home.forEach((p) => (p.hb = false));
              G.pl.away.forEach((p) => (p.hb = false));
              pt.hb = true;
              G.ball.x = pt.x;
              G.ball.y = pt.y;
              G.sel = pt;
              
              // KRITIKUS: Reset mozgÃ¡s Ã¡llapot passzolÃ¡s elkapÃ¡skor is
              pt.moveState = 'rest';
              pt.moveStartTime = Date.now();
              pt.moveTargetX = undefined;
              pt.moveTargetY = undefined;
              
              // EXTRA KRITIKUS: Reset targetBx/targetBy is!
              pt.targetBx = undefined;
              pt.targetBy = undefined;
              pt.bx = pt.x;
              pt.by = pt.y;
              
              G.state = "playing";
              uIns();
              return;
            }
          }
          if (t < 1) requestAnimationFrame(s);
          else fTurn();
        }
        requestAnimationFrame(s);
      }

      function cGoal() {
        const b = G.ball,
          gL = G.fx + (G.fw - G.gw) / 2,
          gR = gL + G.gw;
        if (b.y <= G.fy && b.x >= gL && b.x <= gR) {
          // Kapu pozÃ­ciÃ³ alapÃº gÃ³l esÃ©ly szÃ¡mÃ­tÃ¡s
          const gCenter = gL + G.gw / 2;
          const distFromCenter = Math.abs(b.x - gCenter);
          const distPercent = (distFromCenter / (G.gw / 2)) * 100; // 0-100%
          
          let goalChance;
          if (distPercent <= 20) {
            goalChance = 0.01; // Kapu kÃ¶zepe (0-20%): 1% gÃ³l esÃ©ly
          } else if (distPercent <= 50) {
            goalChance = 0.20; // Kapu 20-50%: 20% gÃ³l esÃ©ly
          } else if (distPercent <= 75) {
            goalChance = 0.35; // Kapu 50-75%: 35% gÃ³l esÃ©ly
          } else {
            goalChance = 0.50; // Kapu 75-100%: 50% gÃ³l esÃ©ly
          }
          
          if (Math.random() < goalChance) {
            sGoal("home");
            return true;
          } else {
            // VÃ©dÃ©s
            const k = G.pl.away.find((p) => p.position === "GK");
            if (k) {
              doSave(k, "away");
              return true;
            }
          }
        }
        if (b.y >= G.fy + G.fh && b.x >= gL && b.x <= gR) {
          // Kapu pozÃ­ciÃ³ alapÃº gÃ³l esÃ©ly szÃ¡mÃ­tÃ¡s
          const gCenter2 = gL + G.gw / 2;
          const distFromCenter2 = Math.abs(b.x - gCenter2);
          const distPercent2 = (distFromCenter2 / (G.gw / 2)) * 100;
          
          let goalChance2;
          if (distPercent2 <= 20) {
            goalChance2 = 0.01; // Kapu kÃ¶zepe: 1%
          } else if (distPercent2 <= 50) {
            goalChance2 = 0.20; // 20-50%: 20%
          } else if (distPercent2 <= 75) {
            goalChance2 = 0.35; // 50-75%: 35%
          } else {
            goalChance2 = 0.50; // 75-100%: 50%
          }
          
          if (Math.random() < goalChance2) {
            sGoal("away");
            return true;
          } else {
            // VÃ©dÃ©s
            const k = G.pl.home.find((p) => p.position === "GK");
            if (k) {
              doSave(k, "home");
              return true;
            }
          }
        }
        return false;
      }

      function doSave(k, t) {
        G.pl.home.forEach((p) => (p.hb = false));
        G.pl.away.forEach((p) => (p.hb = false));
        k.hb = true;
        G.ball.x = k.x;
        G.ball.y = k.y;
        G.sel = k;
        G.turn = t;
        G.poss = t;
        G.passesAfterWin = 0;
        G.ballWinner = k; // BeÃ¡llÃ­tjuk a kapust
        
        // KRITIKUS: Reset mozgÃ¡s Ã¡llapot vÃ©dÃ©skor is
        k.moveState = 'rest';
        k.moveStartTime = Date.now();
        k.moveTargetX = undefined;
        k.moveTargetY = undefined;
        
        // EXTRA KRITIKUS: Reset targetBx/targetBy is!
        k.targetBx = undefined;
        k.targetBy = undefined;
        k.bx = k.x;
        k.by = k.y;
        
        G.state = "playing";
        updFP();
        uUI();
        addFT(k.x, k.y - 18, "VÃ‰DÃ‰S!", "#22c55e");
      }

      function sGoal(t) {
        G.state = "goal";
        if (t === "home") {
          G.hs++;
          document.getElementById("hs").textContent = G.hs;
          
          // XP reward for goal scored (only for player's team)
          if (G.playersDB.length > 0) {
            addUserXP(10); // +10 XP per goal
            updateDebugUI(); // Update UI
          }
        } else {
          G.as++;
          document.getElementById("as").textContent = G.as;
        }
        const sn = G.lastK ? G.lastK.name : "?";
        document.getElementById("gsc").textContent =
          `${t === "home" ? G.ht.flag : G.at.flag} (${G.hs} - ${G.as})`;
        document.getElementById("go").classList.add("a");
        setTimeout(() => {
          document.getElementById("go").classList.remove("a");
          // NO MORE GOAL LIMIT CHECK - match continues until timer ends
          rAG(t === "home" ? "away" : "home");
        }, 2500);
      }

      function rAG(kt) {
        // kt = kickoff team (aki gÃ³lt kapott, Å‘ kezd)
        G.poss = kt;
        G.passesAfterWin = 0;
        G.ballWinner = null;
        
        // INSTANT TELEPORT - azonnal pozÃ­ciÃ³ba Ã¡llÃ­tjuk a csapatokat
        ["home", "away"].forEach((t) => {
          let fm = t === "home" ? G.hf : G.af;
          
          // Default fallback
          if (!fm) fm = '4-4-2';
          
          let fd = FMS[fm];
          
          // Fallback if formation not found
          if (!fd) {
            console.error(`rAG: Formation ${fm} not found in FMS! Using 4-4-2 fallback.`);
            fd = FMS['4-4-2'];
            fm = '4-4-2';
          }
          
          // Ki vÃ©dekezik, ki tÃ¡mad
          const isAttacking = (G.poss === t);
          const ps = isAttacking ? fd.a : fd.d;
          
          G.pl[t].forEach((p, i) => {
            const pp = ps[i];
            let fx, fy;
            if (t === "home") {
              fx = G.fx + pp.x * G.fw;
              fy = G.fy + G.fh - pp.y * G.fh;
            } else {
              fx = G.fx + (1 - pp.x) * G.fw;
              fy = G.fy + pp.y * G.fh;
            }
            
            // INSTANT TELEPORT - nincs animÃ¡ciÃ³!
            p.x = fx;
            p.y = fy;
            p.bx = fx;
            p.by = fy;
            p.hb = false;
            
            // TELJES RESET - minden animÃ¡ciÃ³ Ã¡llapot
            p.targetBx = undefined;
            p.targetBy = undefined;
            p.moveState = 'rest';
            p.moveStartTime = Date.now();
            p.moveTargetX = undefined;
            p.moveTargetY = undefined;
          });
        });
        
        // Az egyik CB kapja meg a labdÃ¡t (aki gÃ³lt kapott)
        const cbList = G.pl[kt].filter(p => p.position === "CB");
        const kickoffPlayer = cbList.length > 0 ? cbList[0] : G.pl[kt][1]; // ElsÅ‘ CB vagy mÃ¡sodik jÃ¡tÃ©kos
        
        kickoffPlayer.hb = true;
        G.ball.x = kickoffPlayer.x;
        G.ball.y = kickoffPlayer.y;
        G.sel = kickoffPlayer;
        G.turn = kt;
        G.state = "playing";
        uUI();
      }

      function fTurn() {
        let md = 1e9,
          nr = null;
        [...G.pl.home, ...G.pl.away].forEach((p) => {
          const d = Math.hypot(p.x - G.ball.x, p.y - G.ball.y);
          if (d < md) {
            md = d;
            nr = p;
          }
        });
        G.turn = nr ? nr.team : G.turn === "home" ? "away" : "home";
        G.poss = G.turn;
        
        console.log(`ğŸ”„ fTurn: Ball at (${G.ball.x.toFixed(0)}, ${G.ball.y.toFixed(0)}), Turn: ${G.turn}`);
        
        abn(G.turn);
        
        // CRITICAL SAFETY CHECK: Force assign if abn failed
        const ballOwner = [...G.pl.home, ...G.pl.away].find(p => p.hb);
        
        if (!ballOwner) {
          console.error('âš ï¸ CRITICAL: abn() failed to assign ball! Force assigning...');
          
          // Force assign to nearest player of current turn
          let closestPlayer = null;
          let closestDist = Infinity;
          G.pl[G.turn].forEach((p) => {
            const d = Math.hypot(p.x - G.ball.x, p.y - G.ball.y);
            if (d < closestDist) {
              closestDist = d;
              closestPlayer = p;
            }
          });
          
          if (closestPlayer) {
            console.log(`âœ… Force assigned to ${closestPlayer.position} (dist: ${closestDist.toFixed(0)})`);
            G.pl.home.forEach((p) => (p.hb = false));
            G.pl.away.forEach((p) => (p.hb = false));
            closestPlayer.hb = true;
            closestPlayer.moveState = 'rest';
            G.ball.x = closestPlayer.x;
            G.ball.y = closestPlayer.y;
            G.sel = closestPlayer;
          } else {
            console.error('âŒ CRITICAL: Could not find any player to assign ball!');
          }
        } else {
          console.log(`âœ“ Ball owner: ${ballOwner.team} ${ballOwner.position}`);
        }
        
        G.state = "playing";
        updFP();
        uUI();
      }

      function endM() {
        G.state = "mo";
        
        // XP Rewards based on result
        if (G.playersDB.length > 0) {
          let xpReward = 0;
          let coinReward = 0;
          
          if (G.hs > G.as) {
            // WIN
            xpReward = 100;
            coinReward = 50;
          } else if (G.hs === G.as) {
            // DRAW
            xpReward = 50;
            coinReward = 20;
          } else {
            // LOSS
            xpReward = 20;
            coinReward = 10;
          }
          
          // Clean sheet bonus (home team didn't concede)
          if (G.as === 0 && G.hs > 0) {
            xpReward += 30;
            coinReward += 20;
          }
          
          // Add rewards
          const levelUps = addUserXP(xpReward);
          G.userSquad.coins += coinReward;
          saveUserData();
          updateDebugUI(); // Update UI
          
          console.log(`âœ… Match complete! +${xpReward} XP, +${coinReward} coins`);
          
          // Show level ups
          if (levelUps.length > 0) {
            levelUps.forEach(lu => {
              console.log(`ğŸ‰ LEVEL UP! Level ${lu.level}`, lu.reward);
            });
          }
        }
        
        document.getElementById("moT").textContent =
          G.hs > G.as ? `${G.ht.flag} ${G.ht.code} wins!` :
          G.hs < G.as ? `${G.at.flag} ${G.at.code} wins!` :
          "âš–ï¸ DRAW";
        document.getElementById("moS").textContent = `${G.hs} - ${G.as}`;
        document.getElementById("moSb").textContent =
          `${G.ht.code} vs ${G.at.code}`;
        document.getElementById("mo").classList.add("a");
      }

      // AI
      let aiPending = false;
      function aiT() {
        if (G.state !== "playing" || G.turn !== "away" || aiPending) return;
        aiPending = true;
        const p = G.sel;
        if (!p) {
          aiPending = false;
          return;
        }
        setTimeout(
          () => {
            aiPending = false;
            if (G.state !== "playing" || G.turn !== "away") return;
            const gx = G.fx + G.fw / 2,
              gy = G.fy + G.fh,
              dg = Math.hypot(p.x - gx, p.y - gy);
            let dx, dy, pw;
            
            // CHECK 1: Team support - how many teammates are ahead or nearby?
            const teamAhead = G.pl.away.filter(t => t.y > p.y + G.fh * 0.05 && t.id !== p.id); // Reduced threshold
            const teamNearby = G.pl.away.filter(t => {
              if (t.id === p.id) return false;
              const dist = Math.hypot(t.x - p.x, t.y - p.y);
              return dist < G.fw * 0.4; // Within 40% of field width
            });
            const hasSupport = teamAhead.length >= 1 || teamNearby.length >= 2; // More flexible
            
            // CHECK 2: Distance to goal
            const veryCloseToGoal = dg < G.fh * 0.40; // INCREASED: 30% â†’ 40% (shoots from further!)
            const closeToGoal = dg < G.fh * 0.50; // Enlarged shooting range
            const mediumDistance = dg < G.fh * 0.70; // Enlarged passing range
            
            // CHECK 3: Clear shot to goal? (RELAXED - allow shooting with some defenders)
            const hasPathToGoal = () => {
              // Check if there are MANY defenders blocking (not just one)
              const defendersInWay = G.pl.home.filter(def => {
                if (def.position === 'GK') return false;
                const isInLine = Math.abs(def.x - p.x) < G.fw * 0.20; // WIDER: 15% â†’ 20%
                const isBetween = def.y > p.y && def.y < gy - G.fh * 0.05; // CLOSER: 10% â†’ 5%
                return isInLine && isBetween;
              }).length;
              return defendersInWay <= 1; // RELAXED: Allow 1 defender (was 0)
            };
            
            // DECISION TREE
            
            // 1. CLOSE TO GOAL = SHOOT! (MUCH MORE AGGRESSIVE)
            // Shoot if reasonably close, even with defenders
            const shouldShoot = closeToGoal || (veryCloseToGoal); // Shoot from 50% distance!
            
            if (shouldShoot) {
              // Intelligent shooting - aim for goal, prefer corners but INSIDE goal
              const gkPos = G.pl.home.find((pl) => pl.position === "GK");
              
              // Goal boundaries
              const goalLeft = G.fx + (G.fw - G.gw) / 2;
              const goalRight = G.fx + (G.fw + G.gw) / 2;
              const goalCenter = G.fx + G.fw / 2;
              
              let tx = goalCenter; // Default: center
              
              const shootStrategy = Math.random();
              
              // Aim INSIDE goal with some randomness
              if (shootStrategy < 0.40) {
                // Left side (40%) - between 15-45% into goal
                tx = goalLeft + G.gw * (0.15 + Math.random() * 0.30);
              } else if (shootStrategy < 0.80) {
                // Right side (40%) - between 55-85% into goal
                tx = goalLeft + G.gw * (0.55 + Math.random() * 0.30);
              } else {
                // Center (20%) - between 35-65%
                tx = goalLeft + G.gw * (0.35 + Math.random() * 0.30);
              }
              
              // Aim away from goalkeeper (if visible)
              if (gkPos) {
                const gkRelativePos = (gkPos.x - goalLeft) / G.gw; // 0-1 within goal
                
                if (gkRelativePos < 0.4) {
                  // GK on left side â†’ shoot right (60-85%)
                  tx = goalLeft + G.gw * (0.60 + Math.random() * 0.25);
                } else if (gkRelativePos > 0.6) {
                  // GK on right side â†’ shoot left (15-40%)
                  tx = goalLeft + G.gw * (0.15 + Math.random() * 0.25);
                } else {
                  // GK center â†’ random corner
                  if (Math.random() < 0.5) {
                    tx = goalLeft + G.gw * (0.15 + Math.random() * 0.20);
                  } else {
                    tx = goalLeft + G.gw * (0.65 + Math.random() * 0.20);
                  }
                }
              }
              
              // CRITICAL: Check if shooting path is clear of defenders
              // RELAXED: Only block if defender is VERY close and directly in line
              const shotBlocked = G.pl.home.some(def => {
                if (def.position === 'GK') return false;
                const defDist = Math.hypot(def.x - p.x, def.y - p.y);
                if (defDist > dg * 0.5) return false; // CHANGED: Only check close defenders (50% of goal distance)
                
                // Check if defender is in the shot cone
                const shotAngle = Math.atan2(gy - p.y, tx - p.x);
                const defAngle = Math.atan2(def.y - p.y, def.x - p.x);
                const angleDiff = Math.abs(shotAngle - defAngle);
                
                // NARROWER cone (0.3) - only block if DIRECTLY in line
                return angleDiff < 0.3 && defDist < dg * 0.4; // Much stricter!
              });
              
              if (shotBlocked) {
                // Shot blocked - TRY ALTERNATIVE ANGLE!
                // ALWAYS try to shoot around, not just veryCloseToGoal
                const blockingDef = G.pl.home.find(def => {
                  if (def.position === 'GK') return false;
                  const defDist = Math.hypot(def.x - p.x, def.y - p.y);
                  if (defDist > dg * 0.5) return false;
                  const shotAngle = Math.atan2(gy - p.y, tx - p.x);
                  const defAngle = Math.atan2(def.y - p.y, def.x - p.x);
                  const angleDiff = Math.abs(shotAngle - defAngle);
                  return angleDiff < 0.3 && defDist < dg * 0.4;
                });
                
                if (blockingDef) {
                  // Shoot to opposite side
                  if (blockingDef.x < goalCenter) {
                    // Defender on left â†’ shoot right
                    tx = goalLeft + G.gw * (0.65 + Math.random() * 0.20);
                  } else {
                    // Defender on right â†’ shoot left
                    tx = goalLeft + G.gw * (0.15 + Math.random() * 0.20);
                  }
                  
                  // SHOOT AROUND DEFENDER!
                  tx = Math.max(goalLeft + 5, Math.min(tx, goalRight - 5));
                  const ddx = tx - p.x,
                    ddy = gy - p.y,
                    l = Math.hypot(ddx, ddy);
                  dx = ddx / l;
                  dy = ddy / l;
                  pw = 0.70 + Math.random() * 0.15; // Slightly weaker (aiming around)
                } else {
                  // No blocking defender found - JUST SHOOT!
                  tx = Math.max(goalLeft + 5, Math.min(tx, goalRight - 5));
                  const ddx = tx - p.x,
                    ddy = gy - p.y,
                    l = Math.hypot(ddx, ddy);
                  dx = ddx / l;
                  dy = ddy / l;
                  pw = 0.75 + Math.random() * 0.20;
                }
              } else {
                // Clear shot - SHOOT!
                // ENSURE target is within goal bounds
                tx = Math.max(goalLeft + 5, Math.min(tx, goalRight - 5));
                
                const ddx = tx - p.x,
                  ddy = gy - p.y,
                  l = Math.hypot(ddx, ddy);
                dx = ddx / l;
                dy = ddy / l;
                pw = 0.75 + Math.random() * 0.20; // Strong shot
              }
            }
            
            // 2. CLOSE BUT NO SUPPORT = PASS BACK/SIDEWAYS AND WAIT
            if (!dx && closeToGoal && !hasSupport) {
              // Find teammate behind or sideways to pass back
              const safeTargets = G.pl.away.filter(t => {
                if (t.id === p.id) return false;
                const isBehind = t.y < p.y;
                const isSideways = Math.abs(t.y - p.y) < G.fh * 0.1;
                const notTooFar = Math.hypot(t.x - p.x, t.y - p.y) < G.fw * 0.5;
                
                // IMPROVED: Check if pass is blocked by defenders
                const passBlocked = G.pl.home.some(def => {
                  if (def.position === 'GK') return false;
                  const passAngle = Math.atan2(t.y - p.y, t.x - p.x);
                  const defAngle = Math.atan2(def.y - p.y, def.x - p.x);
                  const angleDiff = Math.abs(passAngle - defAngle);
                  const defDist = Math.hypot(def.x - p.x, def.y - p.y);
                  const targetDist = Math.hypot(t.x - p.x, t.y - p.y);
                  return angleDiff < 0.4 && defDist < targetDist * 0.7; // Defender blocking
                });
                
                return (isBehind || isSideways) && notTooFar && !passBlocked;
              });
              
              if (safeTargets.length > 0) {
                // Pass to safest teammate
                const target = safeTargets.sort((a, b) => {
                  const distA = Math.hypot(a.x - p.x, a.y - p.y);
                  const distB = Math.hypot(b.x - p.x, b.y - p.y);
                  return distA - distB; // Closest first
                })[0];
                
                const ddx = target.x - p.x,
                  ddy = target.y - p.y,
                  l = Math.hypot(ddx, ddy);
                dx = ddx / l;
                dy = ddy / l;
                pw = 0.40 + Math.random() * 0.20; // Medium pass
              } else {
                // No safe pass - hold ball (small dribble)
                dx = (Math.random() - 0.5) * 0.4;
                dy = Math.random() * 0.3;
                const l = Math.hypot(dx, dy);
                dx /= l;
                dy /= l;
                pw = 0.20 + Math.random() * 0.15;
              }
            }
            // 3. MEDIUM DISTANCE + HAS SUPPORT = PASS FORWARD
            if (!dx && mediumDistance && hasSupport) {
              const forwardTargets = G.pl.away.filter((t) => {
                if (t.id === p.id) return false;
                const ahead = t.y > p.y + G.fh * 0.08;
                const notTooFar = Math.hypot(t.x - p.x, t.y - p.y) < G.fw * 0.6;
                
                // IMPROVED: Check if pass is blocked
                const passBlocked = G.pl.home.some(def => {
                  if (def.position === 'GK') return false;
                  const passAngle = Math.atan2(t.y - p.y, t.x - p.x);
                  const defAngle = Math.atan2(def.y - p.y, def.x - p.x);
                  const angleDiff = Math.abs(passAngle - defAngle);
                  const defDist = Math.hypot(def.x - p.x, def.y - p.y);
                  const targetDist = Math.hypot(t.x - p.x, t.y - p.y);
                  return angleDiff < 0.4 && defDist < targetDist * 0.7;
                });
                
                return ahead && notTooFar && !passBlocked;
              });
              
              if (forwardTargets.length > 0) {
                // IMPROVED: Prefer BEST POSITIONED players, not just closest
                // Score each target by: distance to goal + openness
                forwardTargets.sort((a, b) => {
                  const aDistToGoal = Math.hypot(a.x - gx, a.y - gy);
                  const bDistToGoal = Math.hypot(b.x - gx, b.y - gy);
                  
                  // Check how "open" each player is (fewer defenders nearby)
                  const aOpenness = G.pl.home.filter(def => {
                    const dist = Math.hypot(def.x - a.x, def.y - a.y);
                    return dist < G.fw * 0.2;
                  }).length;
                  const bOpenness = G.pl.home.filter(def => {
                    const dist = Math.hypot(def.x - b.x, def.y - b.y);
                    return dist < G.fw * 0.2;
                  }).length;
                  
                  // Prefer: closer to goal AND more open
                  const aScore = aDistToGoal + (aOpenness * 100); // Penalty for defenders nearby
                  const bScore = bDistToGoal + (bOpenness * 100);
                  return aScore - bScore; // Lower score = better
                });
                
                // Pick BEST positioned (not random!)
                const target = forwardTargets[0]; // Best positioned
                const ddx = target.x - p.x,
                  ddy = target.y - p.y,
                  l = Math.hypot(ddx, ddy);
                dx = ddx / l;
                dy = ddy / l;
                pw = 0.55 + Math.random() * 0.25; // Strong accurate pass
              } else {
                // No forward target - dribble slowly
                dx = (Math.random() - 0.5) * 0.5;
                dy = 0.8;
                const l = Math.hypot(dx, dy);
                dx /= l;
                dy /= l;
                pw = 0.25 + Math.random() * 0.20;
              }
            }
            // 4. FAR FROM GOAL = BUILD UP PLAY
            if (!dx) {
              // Find any teammate to pass to
              const anyTargets = G.pl.away.filter((t) => {
                if (t.id === p.id) return false;
                const notTooClose = Math.hypot(t.x - p.x, t.y - p.y) > G.fw * 0.15;
                const notTooFar = Math.hypot(t.x - p.x, t.y - p.y) < G.fw * 0.65;
                
                // IMPROVED: Check if pass is blocked
                const passBlocked = G.pl.home.some(def => {
                  if (def.position === 'GK') return false;
                  const passAngle = Math.atan2(t.y - p.y, t.x - p.x);
                  const defAngle = Math.atan2(def.y - p.y, def.x - p.x);
                  const angleDiff = Math.abs(passAngle - defAngle);
                  const defDist = Math.hypot(def.x - p.x, def.y - p.y);
                  const targetDist = Math.hypot(t.x - p.x, t.y - p.y);
                  return angleDiff < 0.4 && defDist < targetDist * 0.7;
                });
                
                return notTooClose && notTooFar && !passBlocked;
              });
              
              if (anyTargets.length > 0) {
                // Prefer forward passes, but accept sideways/back
                anyTargets.sort((a, b) => b.y - a.y);
                const target = anyTargets[Math.floor(Math.random() * Math.min(4, anyTargets.length))];
                const ddx = target.x - p.x,
                  ddy = target.y - p.y,
                  l = Math.hypot(ddx, ddy);
                dx = ddx / l;
                dy = ddy / l;
                pw = 0.50 + Math.random() * 0.25;
              } else {
                // Dribble forward
                dx = (Math.random() - 0.5) * 0.5;
                dy = 1;
                const l = Math.hypot(dx, dy);
                dx /= l;
                dy /= l;
                pw = 0.30 + Math.random() * 0.20;
              }
            }
            
            kick(p, dx, dy, pw);
          },
          600 + Math.random() * 600, // 600-1200ms delay
        );
      }

      // Input
      let tid = null,
        md = false;
      function gP(cx, cy) {
        const r = C.getBoundingClientRect();
        return { x: cx - r.left, y: cy - r.top };
      }
      C.addEventListener(
        "touchstart",
        (e) => {
          e.preventDefault();
          if (G.state !== "playing" || G.turn !== "home") return;
          const t = e.touches[0];
          tid = t.identifier;
          const p = gP(t.clientX, t.clientY);
          
          // Ha van labdÃ¡t birtoklÃ³ jÃ¡tÃ©kos, BÃRHONNAN lehet rÃºgni!
          const ballOwner = G.pl[G.turn].find((pp) => pp.hb);
          if (ballOwner) {
            G.ds = p;
            G.dc = p;
          }
        },
        { passive: false },
      );
      C.addEventListener(
        "touchmove",
        (e) => {
          e.preventDefault();
          if (!G.ds) return;
          for (let i = 0; i < e.touches.length; i++)
            if (e.touches[i].identifier === tid) {
              G.dc = gP(e.touches[i].clientX, e.touches[i].clientY);
              break;
            }
        },
        { passive: false },
      );
      C.addEventListener(
        "touchend",
        (e) => {
          e.preventDefault();
          if (G.ds && G.dc && G.sel) {
            const dx = G.ds.x - G.dc.x,
              dy = G.ds.y - G.dc.y,
              l = Math.hypot(dx, dy);
            if (l > 15) kick(G.sel, dx / l, dy / l, Math.min(l / 150, 1));
          }
          G.ds = null;
          G.dc = null;
          document.getElementById("pb").style.display = "none";
        },
        { passive: false },
      );
      C.addEventListener("mousedown", (e) => {
        if (G.state !== "playing" || G.turn !== "home") return;
        const p = gP(e.clientX, e.clientY);
        
        // Ha van labdÃ¡t birtoklÃ³ jÃ¡tÃ©kos, BÃRHONNAN lehet rÃºgni!
        // Nem kell pontosan rÃ¡kattintani a jÃ¡tÃ©kosra
        const ballOwner = G.pl[G.turn].find((pp) => pp.hb);
        if (ballOwner) {
          G.ds = p;
          G.dc = p;
          md = true;
        }
      });
      C.addEventListener("mousemove", (e) => {
        if (!md || !G.ds) return;
        G.dc = gP(e.clientX, e.clientY);
      });
      C.addEventListener("mouseup", (e) => {
        if (md && G.ds && G.dc && G.sel) {
          const dx = G.ds.x - G.dc.x,
            dy = G.ds.y - G.dc.y,
            l = Math.hypot(dx, dy);
          if (l > 15) kick(G.sel, dx / l, dy / l, Math.min(l / 150, 1));
        }
        md = false;
        G.ds = null;
        G.dc = null;
        document.getElementById("pb").style.display = "none";
      });

      function addFT(x, y, text, color) {
        const f = { x, y, a: 1, text, color };
        G.anims.push(f);
        (function fade() {
          f.a -= 0.02;
          f.y -= 0.5;
          if (f.a > 0) requestAnimationFrame(fade);
          else G.anims = G.anims.filter((a) => a !== f);
        })();
      }
      function uUI() {
        const i = document.getElementById("ti");
        if (G.turn === "home") {
          i.textContent = `${G.ht.flag} ${G.ht.code} kicks`;
          i.style.background = "rgba(59,130,246,.2)";
          i.style.color = "#93c5fd";
          i.style.border = "1px solid rgba(59,130,246,.4)";
        } else {
          i.textContent = `${G.at.flag} ${G.at.code} kicks`;
          i.style.background = "rgba(239,68,68,.2)";
          i.style.color = "#fca5a5";
          i.style.border = "1px solid rgba(239,68,68,.4)";
        }
        uIns();
      }
      function uIns() {
        document.getElementById("ins").textContent =
          G.turn === "home" && G.state === "playing"
            ? "Pull back to curve the shot"
            : "";
      }

      // Menus
      function hAll() {
        document
          .querySelectorAll(".ov")
          .forEach((o) => o.classList.remove("a"));
        document.getElementById("mo").classList.remove("a");
      }
      function bMenu() {
        hAll();
        document.getElementById("scoreboard").classList.remove("active");
        document.getElementById("menu").classList.add("a");
        G.state = "menu";
        
        // Hide pause button + pause menu
        document.getElementById('pauseBtn').style.display = 'none';
        document.getElementById('pauseMenu').style.display = 'none';
        
        // Show player debug in menu
        const playerDebug = document.getElementById('playerDebug');
        if (playerDebug) {
          playerDebug.style.display = 'block';
          updateDebugUI();
        }
      }
      function openQM() {
        G.mode = "qm";
        G.step = "home";
        // RESET previous selections
        G.ht = null;
        G.at = null;
        G.hf = null;
        G.af = null;
        hAll();
        sTSel("Choose HOME team");
      }
      function sTSel(title) {
        hAll();
        document.getElementById("tsel").classList.add("a");
        document.getElementById("tst").textContent = title;
        document.getElementById("tsrch").value = "";
        document.getElementById("tsrch").oninput = filt;
        
        // Add BACK button if away step
        const titleEl = document.getElementById("tst");
        if (G.step === "away" && title.includes("AWAY")) {
          titleEl.innerHTML = `
            <button class="b" onclick="goBackToHome()" style="float: left; margin-right: 10px;">â† Back</button>
            ${title}
          `;
        } else {
          titleEl.textContent = title;
        }
        
        // Update squad player count
        const squadCountEl = document.getElementById("squadPlayerCount");
        if (squadCountEl) {
          squadCountEl.textContent = G.userSquad.players.length;
        }
        
        rTG();
      }
      
      function goBackToHome() {
        // Reset away team and go back to home selection
        G.at = null;
        G.step = "home";
        sTSel("Choose HOME team");
      }
      function rTG(f = "") {
        const gr = document.getElementById("tgr");
        const fl = f.toLowerCase();
        gr.innerHTML = "";
        
        // Filter by continent
        let availableTeams = TEAMS;
        if (SELECTED_CUP && SELECTED_CUP !== 'WC') {
          const continentMap = {
            'EURO': 'UEFA',
            'AFCON': 'CAF',
            'COPA': 'CONMEBOL',
            'AFC': 'AFC',
            'CONCACAF': 'CONCACAF'
          };
          const continent = continentMap[SELECTED_CUP];
          availableTeams = TEAMS.filter(t => t.continent === continent || t.code === 'MY_SQUAD');
        }
        
        availableTeams
          .filter((t) => t.name.toLowerCase().includes(fl))
          .forEach((t) => {
            // Calculate average rating based on FIFA rank (or My Squad rating)
            let avgRating = 75;
            if (t.code === 'MY_SQUAD') {
              avgRating = t.avgRating;
            } else {
              // Use database + formation based rating
              avgRating = getNationalTeamAverageRating(t.code);
            }
            
            const c = document.createElement("div");
            c.className = "tc";
            
            // Visual feedback for selected teams
            const isHomeTeam = G.ht && G.ht.code === t.code;
            const isAwayTeam = G.at && G.at.code === t.code;
            
            if (isHomeTeam) {
              c.style.border = "2px solid #3b82f6";
              c.style.background = "rgba(59, 130, 246, 0.1)";
            } else if (isAwayTeam) {
              c.style.border = "2px solid #ef4444";
              c.style.background = "rgba(239, 68, 68, 0.1)";
            }
            
            c.innerHTML = `
              <span class="f">${t.flag}</span>
              <div class="i">
                <div class="n">${t.name}</div>
                <div class="r" style="color: #facc15; font-size: 10px;">AVG: ${avgRating}</div>
              </div>
            `;
            c.onclick = () => selT(t);
            gr.appendChild(c);
          });
      }
      function filt() {
        rTG(document.getElementById("tsrch").value);
      }
      function selT(t) {
        if (G.step === "home") {
          G.ht = t;
          
          // If My Squad selected, skip formation selection (use squad formation)
          if (t.code === 'MY_SQUAD') {
            G.useMySquad = true;
            G.hf = G.userSquad.formation || '4-4-2';
          } else {
            G.useMySquad = false;
          }
          
          G.step = "away";
          sTSel("Choose AWAY team");
        } else if (G.step === "away") {
          G.at = t;
          
          // CONFIRMATION POPUP
          hAll();
          
          // Remove any existing confirmation
          if (window._confirmDiv) {
            window._confirmDiv.remove();
            window._confirmDiv = null;
          }
          
          const confirmDiv = document.createElement('div');
          confirmDiv.id = 'matchConfirmationPopup';
          confirmDiv.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 99999;
            display: flex;
            align-items: center;
            justify-content: center;
          `;
          
          const innerDiv = document.createElement('div');
          innerDiv.style.cssText = `
            background: linear-gradient(135deg, #1e3a8a 0%, #1e40af 100%);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            text-align: center;
            min-width: 300px;
          `;
          
          innerDiv.innerHTML = `
            <h2 style="color: #facc15; margin-bottom: 20px;">âš½ Start Match?</h2>
            <div style="margin: 20px 0;">
              <div style="color: #60a5fa; margin: 10px 0;">
                <strong>HOME:</strong> ${G.ht.flag} ${G.ht.name}
              </div>
              <div style="color: #f87171; margin: 10px 0;">
                <strong>AWAY:</strong> ${G.at.flag} ${G.at.name}
              </div>
            </div>
            <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
              <button class="b" onclick="confirmStartMatch()" style="background: #22c55e;">
                â–¶ï¸ Start Match
              </button>
              <button class="b" onclick="cancelStartMatch()" style="background: #ef4444;">
                â† Back
              </button>
            </div>
          `;
          
          confirmDiv.appendChild(innerDiv);
          document.body.appendChild(confirmDiv);
          window._confirmDiv = confirmDiv;
        } else if (G.step === "cupTeam") {
          G.ht = t;
          
          if (t.code === 'MY_SQUAD') {
            G.useMySquad = true;
            G.hf = G.userSquad.formation || '4-4-2';
          } else {
            G.useMySquad = false;
            G.hf = getCountryFormation(t.code);
          }
          
          G.step = "hf";
          initCupDraw(); // Continue to cup
        }
      }
      
      function confirmStartMatch() {
        // Remove confirmation dialog
        if (window._confirmDiv) {
          window._confirmDiv.remove();
          window._confirmDiv = null;
        }
        
        // Extra cleanup - remove by ID too
        const popupById = document.getElementById('matchConfirmationPopup');
        if (popupById) {
          popupById.remove();
        }
        
        // If home is My Squad, skip formation selection
        if (G.ht.code === 'MY_SQUAD') {
          startM(); // Direct to match
        } else {
          // Set formations based on country default
          G.hf = getCountryFormation(G.ht.code);
          G.af = getCountryFormation(G.at.code);
          startM(); // Direct to match
        }
      }
      
      function cancelStartMatch() {
        // Remove confirmation dialog
        if (window._confirmDiv) {
          window._confirmDiv.remove();
          window._confirmDiv = null;
        }
        
        // Go back to away team selection
        G.at = null;
        G.step = "away";
        sTSel("Choose AWAY team");
      }
      
      // Get country's default formation
      function getCountryFormation(code) {
        // Real national team formations (2024-2026 data)
        const formations = {
          // UEFA (Europe) - Top teams
          'ESP': '4-3-3', 'FRA': '4-2-3-1', 'ENG': '4-3-3', 'POR': '4-3-3', 
          'NED': '4-3-3', 'BEL': '3-4-3', 'GER': '4-2-3-1', 'CRO': '4-3-3',
          'ITA': '4-3-3', 'SUI': '3-4-2-1', 'DEN': '3-4-3', 'AUT': '4-2-3-1',
          'TUR': '4-1-4-1', 'UKR': '4-3-3', 'NOR': '4-3-3', 'POL': '3-5-2',
          'WAL': '3-4-3', 'SCO': '3-5-2', 'SRB': '3-4-1-2', 'HUN': '3-4-3',
          'SWE': '4-4-2', 'CZE': '4-2-3-1', 'SVK': '4-3-3', 'GRE': '4-2-3-1',
          'ROU': '4-3-3', 'SVN': '4-4-2', 'ALB': '4-2-3-1', 'IRL': '3-5-2',
          'BIH': '4-3-3', 'GEO': '3-5-2', 'ISL': '4-4-2', 'FIN': '3-5-2',
          'NIR': '3-5-2', 'BUL': '4-2-3-1', 'MNE': '4-4-2', 'MKD': '4-2-3-1',
          'ARM': '5-3-2', 'BLR': '4-4-2', 'AZE': '4-2-3-1', 'KOS': '4-2-3-1',
          'CYP': '4-4-2', 'KAZ': '4-4-2', 'LUX': '3-5-2', 'LVA': '4-4-2',
          'LTU': '4-4-2', 'EST': '4-4-2', 'MLT': '5-4-1', 'MDA': '4-4-2',
          'FRO': '4-4-2', 'GIB': '5-4-1', 'AND': '5-4-1', 'LIE': '5-4-1',
          'SMR': '5-4-1', 'ISR': '3-4-3', 'RUS': '4-3-3',
          
          // CONMEBOL (South America)
          'BRA': '4-3-3', 'ARG': '4-3-3', 'URU': '4-4-2', 'COL': '4-2-3-1',
          'CHI': '3-5-2', 'PER': '4-2-3-1', 'ECU': '4-4-2', 'PAR': '4-4-2',
          'VEN': '4-4-2', 'BOL': '4-4-2',
          
          // CAF (Africa)
          'MAR': '4-1-4-1', 'SEN': '4-3-3', 'TUN': '4-3-3', 'ALG': '4-3-3',
          'NGR': '4-3-3', 'CMR': '4-3-3', 'EGY': '4-2-3-1', 'CIV': '4-2-3-1',
          'MLI': '4-3-3', 'GHA': '4-2-3-1', 'BFA': '4-3-3', 'RSA': '4-2-3-1',
          'CPV': '4-3-3', 'GAB': '4-3-3', 'GUI': '4-4-2', 'CGO': '4-4-2',
          'UGA': '4-4-2', 'ZAM': '4-4-2', 'EQG': '4-4-2', 'BEN': '4-3-3',
          'KEN': '4-3-3', 'MTN': '4-4-2', 'NAM': '4-4-2', 'ZIM': '4-4-2',
          'GUI': '4-4-2', 'MAD': '4-4-2', 'LBY': '4-4-2', 'MOZ': '4-4-2',
          'COM': '4-4-2', 'TAN': '4-4-2', 'SUD': '4-4-2', 'TOG': '4-4-2',
          'SLE': '4-4-2', 'MWI': '4-4-2', 'RWA': '4-4-2', 'BDI': '4-4-2',
          'NIG': '4-4-2', 'GAM': '4-4-2', 'CTA': '4-4-2', 'LBR': '4-4-2',
          'MRI': '4-4-2', 'ANG': '4-3-3', 'STP': '5-4-1', 'DJI': '5-4-1',
          'SOM': '5-4-1', 'SSD': '5-4-1', 'SWZ': '4-4-2', 'LES': '5-4-1',
          'SEY': '5-4-1', 'BOT': '4-4-2', 'ERI': '5-4-1', 'CHA': '4-4-2',
          
          // AFC (Asia)
          'JPN': '4-2-3-1', 'KOR': '4-2-3-1', 'IRN': '4-2-3-1', 'AUS': '4-3-3',
          'QAT': '5-3-2', 'KSA': '4-2-3-1', 'IRQ': '4-4-2', 'UAE': '4-2-3-1',
          'OMA': '4-4-2', 'UZB': '4-4-2', 'CHN': '4-3-3', 'JOR': '4-4-2',
          'BHR': '4-4-2', 'SYR': '4-4-2', 'PAL': '4-4-2', 'KGZ': '4-4-2',
          'TJK': '4-4-2', 'VIE': '5-4-1', 'THA': '4-4-2', 'IND': '4-4-2',
          'PHI': '4-4-2', 'MYA': '4-4-2', 'SIN': '4-4-2', 'MAS': '4-4-2',
          'IDN': '4-3-3', 'HKG': '4-4-2',
          
          // CONCACAF (North/Central America)
          'MEX': '4-3-3', 'USA': '4-3-3', 'CRC': '5-4-1', 'JAM': '4-4-2',
          'PAN': '5-3-2', 'CAN': '4-4-2', 'HON': '4-4-2', 'TRI': '4-4-2',
          'CUW': '4-4-2', 'SLV': '4-4-2', 'HAI': '4-4-2', 'NCA': '4-4-2',
          'GUA': '4-4-2', 'GRN': '5-4-1', 'ARU': '5-4-1', 'VGB': '5-4-1',
          'PUR': '4-4-2'
        };
        
        return formations[code] || '4-4-2'; // Default: 4-4-2
      }
      
      // Generate national team squad from database
      function generateNationalSquad(countryCode, formation) {
        // Get formation positions
        const formationMap = {
          "4-3-3": ["GK", "LB", "CB", "CB", "RB", "CM", "CM", "CM", "LW", "ST", "RW"],
          "4-4-2": ["GK", "LB", "CB", "CB", "RB", "LM", "CM", "CM", "RM", "ST", "ST"],
          "5-4-1": ["GK", "LWB", "CB", "CB", "CB", "RWB", "LM", "CM", "CM", "RM", "ST"],
          "3-4-3": ["GK", "CB", "CB", "CB", "LM", "CM", "CM", "RM", "LW", "ST", "RW"],
          "4-2-3-1": ["GK", "LB", "CB", "CB", "RB", "CDM", "CDM", "LM", "CAM", "RM", "ST"],
          "3-5-2": ["GK", "CB", "CB", "CB", "LM", "CM", "CM", "CM", "RM", "ST", "ST"],
          "4-1-4-1": ["GK", "LB", "CB", "CB", "RB", "CDM", "LM", "CM", "CM", "RM", "ST"],
          "3-4-2-1": ["GK", "CB", "CB", "CB", "LM", "CM", "CM", "RM", "CAM", "CAM", "ST"],
          "3-4-1-2": ["GK", "CB", "CB", "CB", "LM", "CM", "CM", "RM", "CAM", "ST", "ST"],
          "5-3-2": ["GK", "LWB", "CB", "CB", "CB", "RWB", "CM", "CM", "CM", "ST", "ST"]
        };
        
        const positions = formationMap[formation] || formationMap["4-4-2"];
        
        // Compatible positions map
        const compatiblePositions = {
          'GK': ['GK'],
          'LB': ['LB', 'LWB'],
          'CB': ['CB'],
          'RB': ['RB', 'RWB'],
          'LWB': ['LB', 'LWB'],
          'RWB': ['RB', 'RWB'],
          'CDM': ['CDM', 'CM'],
          'CM': ['CM', 'CDM', 'CAM'],
          'CAM': ['CAM', 'CM'],
          'LM': ['LM', 'LW', 'CM'],
          'RM': ['RM', 'RW', 'CM'],
          'LW': ['LW', 'LM', 'ST'],
          'RW': ['RW', 'RM', 'ST'],
          'ST': ['ST', 'CF', 'LW', 'RW'],
          'CF': ['CF', 'ST', 'CAM']
        };
        
        const squad = [];
        const usedPlayers = new Set();
        
        // Find players from this country
        const countryPlayers = G.playersDB.filter(p => p.country === countryCode);
        
        if (countryPlayers.length === 0) {
          // No players in DB for this country - return null (will use generic)
          return null;
        }
        
        positions.forEach(slotPos => {
          const allowedPositions = compatiblePositions[slotPos] || [slotPos];
          
          // Find best available player
          const candidate = countryPlayers
            .filter(p => allowedPositions.includes(p.position) && !usedPlayers.has(p.id))
            .sort((a, b) => {
              // Prefer exact position match
              const aExact = a.position === slotPos ? 1 : 0;
              const bExact = b.position === slotPos ? 1 : 0;
              if (aExact !== bExact) return bExact - aExact;
              return b.overall - a.overall;
            })[0];
          
          if (candidate) {
            squad.push(candidate);
            usedPlayers.add(candidate.id);
          } else {
            squad.push(null); // No player for this position
          }
        });
        
        return squad;
      }
      
      function sFSel(title) {
        hAll();
        document.getElementById("fsel").classList.add("a");
        document.getElementById("fst").textContent = title;
        const gr = document.getElementById("fgr");
        gr.innerHTML = "";
        Object.keys(FMS).forEach((f) => {
          const b = document.createElement("button");
          b.className = "fb";
          b.textContent = f;
          b.onclick = () => selF(f);
          gr.appendChild(b);
        });
      }
      function selF(f) {
        // NOT USED ANYMORE - formations are auto-assigned
        // This function is kept for backwards compatibility only
        if (G.step === "hf") {
          G.hf = f;
          
          if (G.mode === "cup") {
            initCupDraw();
            return;
          }
          G.step = "af";
          sFSel("Vendeg Formacio");
        } else {
          G.af = f;
          startM();
        }
      }
      function bTS() {
        if (G.step === "hf") {
          G.step = "away";
          sTSel("Valaszd a VENDEG csapatot");
        } else openQM();
      }

      function startM() {
        hAll();
        const sb = document.getElementById("scoreboard");
        sb.classList.add("active");
        document.getElementById("hf").textContent = G.ht.flag;
        document.getElementById("hn").textContent = G.ht.code;
        document.getElementById("af").textContent = G.at.flag;
        document.getElementById("an").textContent = G.at.code;
        G.hs = 0;
        G.as = 0;
        document.getElementById("hs").textContent = "0";
        document.getElementById("as").textContent = "0";
        
        // Initialize match timer
        G.matchTime = 0;
        G.matchStartTime = Date.now();
        G.goldenGoalMode = false; // Reset golden goal mode
        
        // Hide player debug during match
        const playerDebug = document.getElementById('playerDebug');
        if (playerDebug) {
          playerDebug.style.display = 'none';
        }
        
        resize();
        G.poss = "home";
        G.turn = "home";
        initP();
        G.state = "playing";
        uUI();
        
        // Show pause button during match
        document.getElementById('pauseBtn').style.display = 'block';
      }
      
      // PAUSE MENU
      function togglePause() {
        // Don't allow pause during animations/special states
        if (G.state === "anim" || G.state === "mo") return;
        
        const pauseMenu = document.getElementById('pauseMenu');
        if (pauseMenu.style.display === 'flex') {
          // Resume
          pauseMenu.style.display = 'none';
          if (G.state === "paused") G.state = "playing";
        } else {
          // Pause
          pauseMenu.style.display = 'flex';
          G.state = "paused";
        }
      }
      
      function giveUpMatch() {
        // Give up = opponent wins
        if (confirm('Are you sure you want to give up? You will lose this match!')) {
          G.as = 99; // Opponent wins
          togglePause(); // Close pause menu
          endM(); // End match
        }
      }

      function moCont() {
        document.getElementById("mo").classList.remove("a");
        if (G.mode === "cup" && G.cup) cupMO();
        else bMenu();
      }

      // ==================== CUP ====================
      let SELECTED_CUP = null; // KivÃ¡lasztott kupa tÃ­pusa

      function selectCup(cupType) {
        SELECTED_CUP = cupType;
        G.mode = "cup";
        G.cupType = cupType;
        G.step = "cupTeam";
        hAll();
        document.getElementById("tsel").classList.add("a");
        
        // Cup specific text
        const cupNames = {
          'EURO': 'European Championship 2028 - Choose your European team!',
          'AFCON': 'African Championship 2025 - Choose your African team!',
          'COPA': 'Copa America 2024 - Choose your South American team!',
          'AFC': 'Asian Championship 2027 - Choose your Asian team!',
          'CONCACAF': 'Gold Cup 2025 - Choose your CONCACAF team!',
          'WC': 'World Championship 2026 - Choose your team!'
        };
        
        document.getElementById("tst").textContent = cupNames[cupType];
        document.getElementById("tsrch").value = "";
        document.getElementById("tsrch").oninput = filt;
        rTG();
      }

      function openCup() {
        selectCup('WC'); // Default World Cup
      }

      function initCupDraw() {
        hAll();
        
        // Initialize qualifying rounds for continental cups
        if (SELECTED_CUP === 'WC') {
          initWorldCupQualifiers();
          return;
        }
        
        // Start continental cup qualifying
        switch(SELECTED_CUP) {
          case 'EURO':
            initEuroQualifying();
            break;
          case 'AFCON':
            initAfconQualifying();
            break;
          case 'COPA':
            initCopaQualifying();
            break;
          case 'AFC':
            initAfcQualifying();
            break;
          case 'CONCACAF':
            initConcacafQualifying();
            break;
        }
      }
      
      // UEFA EURO 2028 QUALIFYING: 12 groups (6Ã—4 + 6Ã—5)
      function initEuroQualifying() {
        const teams = TEAMS.filter(t => t.continent === 'UEFA');
        teams.sort((a, b) => a.rank - b.rank);
        
        // 12 groups: 6 with 4 teams, 6 with 5 teams (Total: 54 teams)
        const groups = [];
        const groupSizes = [5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4]; // Total: 54 teams
        
        let teamIndex = 0;
        for (let i = 0; i < 12; i++) {
          const groupSize = groupSizes[i];
          const g = {
            name: String.fromCharCode(65 + i), // A, B, C...
            teams: teams.slice(teamIndex, teamIndex + groupSize),
            matches: [],
          };
          
          // Generate all matches (home & away)
          for (let a = 0; a < g.teams.length; a++) {
            for (let b = a + 1; b < g.teams.length; b++) {
              g.matches.push({
                home: g.teams[a],
                away: g.teams[b],
                hg: null,
                ag: null,
                played: false,
              });
              // Return match
              g.matches.push({
                home: g.teams[b],
                away: g.teams[a],
                hg: null,
                ag: null,
                played: false,
              });
            }
          }
          
          groups.push(g);
          teamIndex += groupSize;
        }
        
        G.cup = { 
          user: G.ht, 
          groups, 
          phase: "qualifying", 
          ko: null,
          type: SELECTED_CUP,
          qualifyingSpots: 20, // Group winners (12) + some runners-up (8)
          playoffSpots: 3 // Via Nations League (simulated)
        };
        showCup();
      }
      
      // AFCON 2025 QUALIFYING: 12 groups Ã— 4 teams (+ preliminary round)
      function initAfconQualifying() {
        const teams = TEAMS.filter(t => t.continent === 'CAF');
        teams.sort((a, b) => a.rank - b.rank);
        
        // 12 groups Ã— 4 teams = 48 teams (after preliminary)
        const groups = [];
        for (let i = 0; i < 12; i++) {
          const g = {
            name: String.fromCharCode(65 + i),
            teams: teams.slice(i * 4, (i + 1) * 4),
            matches: [],
          };
          
          // Generate all matches (home & away)
          for (let a = 0; a < g.teams.length; a++) {
            for (let b = a + 1; b < g.teams.length; b++) {
              g.matches.push({
                home: g.teams[a],
                away: g.teams[b],
                hg: null,
                ag: null,
                played: false,
              });
              g.matches.push({
                home: g.teams[b],
                away: g.teams[a],
                hg: null,
                ag: null,
                played: false,
              });
            }
          }
          
          groups.push(g);
        }
        
        G.cup = { 
          user: G.ht, 
          groups, 
          phase: "qualifying", 
          ko: null,
          type: SELECTED_CUP,
          qualifyingSpots: 24 // Top 2 from each group (12Ã—2)
        };
        showCup();
      }
      
      // Copa America: No traditional qualifying (CONMEBOL teams invited)
      function initCopaQualifying() {
        const teams = TEAMS.filter(t => t.continent === 'CONMEBOL');
        
        // All 10 CONMEBOL teams qualify automatically
        // Add 6 CONCACAF guests (top ranked)
        const concacafTeams = TEAMS.filter(t => t.continent === 'CONCACAF')
          .sort((a, b) => a.rank - b.rank)
          .slice(0, 6);
        
        const allTeams = [...teams, ...concacafTeams];
        
        // 4 groups Ã— 4 teams
        const groups = [];
        allTeams.sort((a, b) => a.rank - b.rank);
        
        // Pot-based distribution
        for (let i = 0; i < 4; i++) {
          const g = {
            name: String.fromCharCode(65 + i),
            teams: [
              allTeams[i],           // Pot 1
              allTeams[i + 4],       // Pot 2
              allTeams[i + 8],       // Pot 3
              allTeams[i + 12]       // Pot 4
            ],
            matches: [],
          };
          
          // Generate matches
          for (let a = 0; a < g.teams.length; a++) {
            for (let b = a + 1; b < g.teams.length; b++) {
              g.matches.push({
                home: g.teams[a],
                away: g.teams[b],
                hg: null,
                ag: null,
                played: false,
              });
            }
          }
          
          groups.push(g);
        }
        
        G.cup = { 
          user: G.ht, 
          groups, 
          phase: "groups", // Copa goes straight to tournament
          ko: null,
          type: SELECTED_CUP,
          knockoutTeams: 8 // Top 2 from each group
        };
        showCup();
      }
      
      // AFC Asian Cup QUALIFYING: Simplified (6 groups Ã— 4 teams in Round 3)
      function initAfcQualifying() {
        const teams = TEAMS.filter(t => t.continent === 'AFC');
        teams.sort((a, b) => a.rank - b.rank);
        
        // Simplified: Round 3 only (24 teams in 6 groups)
        const groups = [];
        for (let i = 0; i < 6; i++) {
          const g = {
            name: String.fromCharCode(65 + i),
            teams: teams.slice(i * 4, (i + 1) * 4),
            matches: [],
          };
          
          // Generate matches
          for (let a = 0; a < g.teams.length; a++) {
            for (let b = a + 1; b < g.teams.length; b++) {
              g.matches.push({
                home: g.teams[a],
                away: g.teams[b],
                hg: null,
                ag: null,
                played: false,
              });
            }
          }
          
          groups.push(g);
        }
        
        G.cup = { 
          user: G.ht, 
          groups, 
          phase: "qualifying", 
          ko: null,
          type: SELECTED_CUP,
          qualifyingSpots: 24 // All 24 teams from Round 3 qualify
        };
        showCup();
      }
      
      // CONCACAF Gold Cup: Simplified via Nations League
      function initConcacafQualifying() {
        const teams = TEAMS.filter(t => t.continent === 'CONCACAF');
        teams.sort((a, b) => a.rank - b.rank);
        
        // Top 16 teams go straight to tournament
        const qualifiedTeams = teams.slice(0, 16);
        
        // 4 groups Ã— 4 teams
        const groups = [];
        for (let i = 0; i < 4; i++) {
          const g = {
            name: String.fromCharCode(65 + i),
            teams: [
              qualifiedTeams[i],
              qualifiedTeams[i + 4],
              qualifiedTeams[i + 8],
              qualifiedTeams[i + 12]
            ],
            matches: [],
          };
          
          // Generate matches
          for (let a = 0; a < g.teams.length; a++) {
            for (let b = a + 1; b < g.teams.length; b++) {
              g.matches.push({
                home: g.teams[a],
                away: g.teams[b],
                hg: null,
                ag: null,
                played: false,
              });
            }
          }
          
          groups.push(g);
        }
        
        G.cup = { 
          user: G.ht, 
          groups, 
          phase: "groups", // CONCACAF goes straight to tournament
          ko: null,
          type: SELECTED_CUP,
          knockoutTeams: 8 // Top 2 from each group
        };
        showCup();
      }
      
      function initWorldCupQualifiers() {
        // World Cup selejtezÅ‘ rendszer
        hAll();
        
        const userContinent = G.ht.continent;
        const continentTeams = TEAMS.filter(t => t.continent === userContinent);
        
        // Kontinens szerinti helyek
        const spots = {
          'UEFA': 13,      // EurÃ³pa - 13 hely
          'CAF': 9,        // Afrika - 9 hely
          'CONMEBOL': 6,   // DÃ©l-Amerika - 6 hely (10-bÅ‘l 6)
          'AFC': 8,        // Ãzsia - 8 hely
          'CONCACAF': 6    // CONCACAF - 6 hely
        };
        
        const qualifierSpots = spots[userContinent];
        
        // SelejtezÅ‘ csoportok
        let numGroups, teamsPerGroup;
        if (userContinent === 'CONMEBOL') {
          // DÃ©l-Amerika: 1 csoport, mindenki-mindenki (10 csapat)
          numGroups = 1;
          teamsPerGroup = 10;
        } else if (userContinent === 'UEFA') {
          // EurÃ³pa: 10 csoport Ã— 5-6 csapat
          numGroups = 10;
          teamsPerGroup = Math.ceil(continentTeams.length / numGroups);
        } else if (userContinent === 'CAF') {
          // Afrika: 9 csoport Ã— 6 csapat
          numGroups = 9;
          teamsPerGroup = 6;
        } else if (userContinent === 'AFC') {
          // Ãzsia: 6 csoport Ã— 4 csapat
          numGroups = 6;
          teamsPerGroup = 4;
        } else {
          // CONCACAF: 3 csoport Ã— 5-6 csapat
          numGroups = 3;
          teamsPerGroup = Math.ceil(continentTeams.length / numGroups);
        }
        
        // SelejtezÅ‘ csoportok sorsolÃ¡sa
        let sortedTeams = [...continentTeams].sort((a, b) => a.rank - b.rank);
        const groups = [];
        
        for (let i = 0; i < numGroups; i++) {
          const g = {
            name: String.fromCharCode(65 + i),
            teams: [],
            matches: [],
          };
          
          // KÃ­gyÃ³ rendszerÅ± sorsolÃ¡s (1,2,3...visszafelÃ©...3,2,1)
          for (let pot = 0; pot < teamsPerGroup; pot++) {
            const idx = pot * numGroups + (pot % 2 === 0 ? i : numGroups - 1 - i);
            if (idx < sortedTeams.length) {
              g.teams.push(sortedTeams[idx]);
            }
          }
          
          // Meccsek (mindenki-mindenki)
          for (let a = 0; a < g.teams.length; a++) {
            for (let b = a + 1; b < g.teams.length; b++) {
              g.matches.push({
                home: g.teams[a],
                away: g.teams[b],
                hg: null,
                ag: null,
                played: false,
              });
            }
          }
          groups.push(g);
        }
        
        G.wcQualifiers = {
          user: G.ht,
          continent: userContinent,
          groups,
          spots: qualifierSpots,
          phase: "groups"
        };
        
        showWCQualifiers();
      }

      function calcSt(g) {
        const m = {};
        g.teams.forEach(
          (t) =>
            (m[t.code] = {
              team: t,
              p: 0,
              w: 0,
              d: 0,
              l: 0,
              gf: 0,
              ga: 0,
              pts: 0,
            }),
        );
        g.matches
          .filter((mm) => mm.played)
          .forEach((mm) => {
            m[mm.home.code].p++;
            m[mm.away.code].p++;
            m[mm.home.code].gf += mm.hg;
            m[mm.home.code].ga += mm.ag;
            m[mm.away.code].gf += mm.ag;
            m[mm.away.code].ga += mm.hg;
            if (mm.hg > mm.ag) {
              m[mm.home.code].w++;
              m[mm.home.code].pts += 3;
              m[mm.away.code].l++;
            } else if (mm.hg < mm.ag) {
              m[mm.away.code].w++;
              m[mm.away.code].pts += 3;
              m[mm.home.code].l++;
            } else {
              m[mm.home.code].d++;
              m[mm.away.code].d++;
              m[mm.home.code].pts++;
              m[mm.away.code].pts++;
            }
          });
        return Object.values(m).sort(
          (a, b) => b.pts - a.pts || b.gf - b.ga - (a.gf - a.ga) || b.gf - a.gf,
        );
      }

      function simMatch(h, a) {
        // Realististic 90-minute match simulation
        // Average goals per match in real football: 2.5-3 total
        
        let hg = 0, ag = 0;
        
        // Simulate based on team strength (rank)
        const homeStrength = 200 - (h.rank || 100); // Lower rank = stronger (inverse)
        const awayStrength = 200 - (a.rank || 100);
        const totalStrength = homeStrength + awayStrength;
        
        const homeWinProb = homeStrength / totalStrength;
        
        // Average 2.7 goals per match (realistic)
        const totalGoals = Math.floor(Math.random() * 2) + Math.floor(Math.random() * 3); // 0-4 goals typically
        
        // Distribute goals based on team strength
        for (let i = 0; i < totalGoals; i++) {
          if (Math.random() < homeWinProb + 0.1) { // Home advantage (+10%)
            hg++;
          } else {
            ag++;
          }
        }
        
        return { hg, ag };
      }

      function findNextGM() {
        // First, try to find user's next match
        for (const g of G.cup.groups) {
          for (const m of g.matches) {
            if (!m.played && (m.home.code === G.cup.user.code || m.away.code === G.cup.user.code)) {
              return { g, m, isUser: true };
            }
          }
        }
        
        // If no user match, find any match
        for (const g of G.cup.groups) {
          for (const m of g.matches) {
            if (!m.played) {
              return { g, m, isUser: false };
            }
          }
        }
        
        return null;
      }

      function showCup() {
        hAll();
        document.getElementById("scoreboard").classList.remove("active");
        document.getElementById("cup").classList.add("a");
        const c = document.getElementById("cupc");
        c.innerHTML = "";
        
        // Cup names
        const cupNames = {
          'EURO': 'ğŸ† European Championship 2026',
          'AFCON': 'ğŸ† African Championship 2026',
          'COPA': 'ğŸ† Copa America 2026',
          'AFC': 'ğŸ† Asian Cup 2026',
          'CONCACAF': 'ğŸ† CONCACAF Gold Cup 2026',
          'WC': 'ğŸŒ World Cup 2026'
        };
        const cupName = cupNames[G.cup.type] || 'ğŸ† Championship';
        
        if (G.cup.phase === "qualifying") {
          // QUALIFYING PHASE
          c.innerHTML = `<h1 class="t">${cupName}</h1><h2 class="s">ğŸ¯ Qualifying Round - ${G.cup.groups.length} groups</h2>`;
          G.cup.groups.forEach((g) => {
            const st = calcSt(g);
            const iu = g.teams.some((t) => t.code === G.cup.user.code);
            const allDone = g.matches.every((m) => m.played);
            const d = document.createElement("div");
            d.style.cssText = `width:100%;margin-bottom:10px;border-radius:7px;overflow:hidden;${iu ? "border:2px solid #3b82f6;" : "border:1px solid #1e293b;"}`;
            let h = `<table class="gt"><tr><th colspan="7">${iu ? "â­ " : ""}Group ${g.name}</th></tr><tr><th></th><th>Pts</th><th>P</th><th>W</th><th>D</th><th>L</th><th>GD</th></tr>`;
            st.forEach((s, si) => {
              const qualified = si < 2 && allDone; // Top 2 qualify
              const u = s.team.code === G.cup.user.code;
              h += `<tr class="${qualified ? "q" : ""}" style="${u ? "font-weight:700;color:#3b82f6;" : ""}"><td>${s.team.flag} ${s.team.code}</td><td>${s.pts}</td><td>${s.p}</td><td>${s.w}</td><td>${s.d}</td><td>${s.l}</td><td>${s.gf}-${s.ga}</td></tr>`;
            });
            h += "</table>";
            g.matches
              .filter((m) => m.played)
              .slice(-3) // Show last 3 matches
              .forEach((m) => {
                h += `<div class="mr">${m.home.flag}${m.home.code} <b>${m.hg}</b>-<b>${m.ag}</b> ${m.away.code}${m.away.flag}</div>`;
              });
            d.innerHTML = h;
            c.appendChild(d);
          });

          const nm = findNextGM();
          if (nm) {
            if (nm.isUser) {
              const b1 = document.createElement("button");
              b1.className = "b";
              b1.textContent = `â–¶ Play Qualifying Match: ${nm.m.home.flag} ${nm.m.home.code} vs ${nm.m.away.code} ${nm.m.away.flag}`;
              b1.onclick = () => playCupM(nm);
              c.appendChild(b1);
            } else {
              // Simulate remaining matches
              while (findNextGM() !== null) {
                const nextMatch = findNextGM();
                if (!nextMatch) break;
                simCupM(nextMatch);
              }
              showCup();
              return;
            }
          } else {
            // Qualifying complete - check if user qualified
            const userGroup = G.cup.groups.find(g => g.teams.some(t => t.code === G.cup.user.code));
            const standings = calcSt(userGroup);
            const userPosition = standings.findIndex(s => s.team.code === G.cup.user.code);
            
            if (userPosition < 2) {
              // User qualified! Show button to start tournament
              const b2 = document.createElement("button");
              b2.className = "b";
              b2.textContent = "âœ… Qualified! â†’ Start Tournament";
              b2.style.background = "#10b981";
              b2.onclick = () => startFinalTournament();
              c.appendChild(b2);
            } else {
              // User eliminated
              const b3 = document.createElement("button");
              b3.className = "b";
              b3.textContent = "âŒ Eliminated from Qualifying";
              b3.style.background = "#ef4444";
              b3.onclick = () => { hAll(); document.getElementById("menu").classList.add("a"); };
              c.appendChild(b3);
            }
          }
        } else if (G.cup.phase === "groups") {
          // TOURNAMENT GROUP STAGE
          c.innerHTML = `<h1 class="t">${cupName}</h1><h2 class="s">Group Stage - ${G.cup.groups.length} groups</h2>`;
          G.cup.groups.forEach((g) => {
            const st = calcSt(g);
            const iu = g.teams.some((t) => t.code === G.cup.user.code);
            const allDone = g.matches.every((m) => m.played);
            const d = document.createElement("div");
            d.style.cssText = `width:100%;margin-bottom:10px;border-radius:7px;overflow:hidden;${iu ? "border:1px solid #facc15;" : "border:1px solid #1e293b;"}`;
            let h = `<table class="gt"><tr><th colspan="7">${iu ? "â­ " : ""}Group ${g.name}</th></tr><tr><th></th><th>Pts</th><th>P</th><th>W</th><th>D</th><th>L</th><th>GD</th></tr>`;
            st.forEach((s, si) => {
              const q = si < 2 && allDone;
              const u = s.team.code === G.cup.user.code;
              h += `<tr class="${q ? "q" : ""}" style="${u ? "font-weight:700;color:#facc15;" : ""}"><td>${s.team.flag} ${s.team.code}</td><td>${s.pts}</td><td>${s.p}</td><td>${s.w}</td><td>${s.d}</td><td>${s.l}</td><td>${s.gf}-${s.ga}</td></tr>`;
            });
            h += "</table>";
            g.matches
              .filter((m) => m.played)
              .forEach((m) => {
                h += `<div class="mr">${m.home.flag}${m.home.code} <b>${m.hg}</b>-<b>${m.ag}</b> ${m.away.code}${m.away.flag}</div>`;
              });
            d.innerHTML = h;
            c.appendChild(d);
          });

          const nm = findNextGM();
          if (nm) {
            if (nm.isUser) {
              // Show user's match button
              const b1 = document.createElement("button");
              b1.className = "b";
              b1.textContent = `â–¶ Play Match: ${nm.m.home.flag} ${nm.m.home.code} vs ${nm.m.away.code} ${nm.m.away.flag}`;
              b1.onclick = () => playCupM(nm);
              c.appendChild(b1);
            } else {
              // Auto-simulate all remaining matches since user has no more matches
              while (findNextGM() !== null) {
                const nextMatch = findNextGM();
                if (!nextMatch) break;
                simCupM(nextMatch);
              }
              // Refresh display
              showCup();
              return;
            }
            
            // Results button - show all matches of current round
            const totalMatches = G.cup.groups.reduce((sum, g) => sum + g.matches.length, 0);
            const playedMatches = G.cup.groups.reduce((sum, g) => sum + g.matches.filter(m => m.played).length, 0);
            
            if (playedMatches > 0) {
              const bResults = document.createElement("button");
              bResults.className = "b b2";
              bResults.style.marginTop = "8px";
              bResults.textContent = `ğŸ“Š View Results (${playedMatches}/${totalMatches} matches played)`;
              bResults.onclick = showResults;
              c.appendChild(bResults);
            }
          } else {
            const b = document.createElement("button");
            b.className = "b bg";
            b.textContent = "ğŸ† Knockout Stage â†’";
            b.onclick = initKO;
            c.appendChild(b);
          }
        } else showKO();

        const bk = document.createElement("button");
        bk.className = "b br";
        bk.style.marginTop = "6px";
        bk.textContent = "Exit";
        bk.onclick = bMenu;
        c.appendChild(bk);
      }
      
      function showWCQualifiers() {
        hAll();
        document.getElementById("scoreboard").classList.remove("active");
        document.getElementById("cup").classList.add("a");
        const c = document.getElementById("cupc");
        c.innerHTML = "";
        
        const continentNames = {
          'UEFA': 'Europe',
          'CAF': 'Africa',
          'CONMEBOL': 'South America',
          'AFC': 'Asia',
          'CONCACAF': 'CONCACAF'
        };
        
        c.innerHTML = `<h1 class="t">ğŸŒ World Championship 2026 Qualifiers</h1><h2 class="s">${continentNames[G.wcQualifiers.continent]} - ${G.wcQualifiers.spots} spots available</h2>`;
        
        G.wcQualifiers.groups.forEach((g) => {
          const st = calcSt(g);
          const iu = g.teams.some((t) => t.code === G.wcQualifiers.user.code);
          const allDone = g.matches.every((m) => m.played);
          const d = document.createElement("div");
          d.style.cssText = `width:100%;margin-bottom:10px;border-radius:7px;overflow:hidden;${iu ? "border:1px solid #facc15;" : "border:1px solid #1e293b;"}`;
          
          // How many teams qualify from this group
          let qualifySpots = 1; // Default: group winners
          if (G.wcQualifiers.continent === 'CONMEBOL') {
            qualifySpots = 6; // Top 6 in South America
          }
          
          let h = `<table class="gt"><tr><th colspan="7">${iu ? "â­ " : ""}Group ${g.name}</th></tr><tr><th></th><th>Pts</th><th>P</th><th>W</th><th>D</th><th>L</th><th>GD</th></tr>`;
          st.forEach((s, si) => {
            const q = si < qualifySpots && allDone;
            const u = s.team.code === G.wcQualifiers.user.code;
            h += `<tr class="${q ? "q" : ""}" style="${u ? "font-weight:700;color:#facc15;" : ""}"><td>${s.team.flag} ${s.team.code}</td><td>${s.pts}</td><td>${s.p}</td><td>${s.w}</td><td>${s.d}</td><td>${s.l}</td><td>${s.gf}-${s.ga}</td></tr>`;
          });
          h += "</table>";
          g.matches
            .filter((m) => m.played)
            .forEach((m) => {
              h += `<div class="mr">${m.home.flag}${m.home.code} <b>${m.hg}</b>-<b>${m.ag}</b> ${m.away.code}${m.away.flag}</div>`;
            });
          d.innerHTML = h;
          c.appendChild(d);
        });
        
        const nm = findNextWCQM();
        if (nm) {
          if (nm.isUser) {
            // Show user's match button
            const b1 = document.createElement("button");
            b1.className = "b";
            b1.textContent = `â–¶ Play Match: ${nm.m.home.flag} ${nm.m.home.code} vs ${nm.m.away.code} ${nm.m.away.flag}`;
            b1.onclick = () => playWCQM(nm);
            c.appendChild(b1);
          } else {
            // Auto-simulate all remaining matches since user has no more matches
            while (findNextWCQM() !== null) {
              const nextMatch = findNextWCQM();
              if (!nextMatch) break;
              simWCQM(nextMatch);
            }
            // Refresh display
            showWCQualifiers();
            return;
          }
          
          // Results button
          const totalMatches = G.wcQualifiers.groups.reduce((sum, g) => sum + g.matches.length, 0);
          const playedMatches = G.wcQualifiers.groups.reduce((sum, g) => sum + g.matches.filter(m => m.played).length, 0);
          
          if (playedMatches > 0) {
            const bResults = document.createElement("button");
            bResults.className = "b b2";
            bResults.style.marginTop = "8px";
            bResults.textContent = `ğŸ“Š View Results (${playedMatches}/${totalMatches} matches played)`;
            bResults.onclick = showResultsWCQ;
            c.appendChild(bResults);
          }
        } else {
          // Qualifiers ended - did we qualify?
          const qualified = checkWCQualification();
          if (qualified) {
            const b = document.createElement("button");
            b.className = "b bg";
            b.style.fontSize = "15px";
            b.innerHTML = "âœ… YOU QUALIFIED FOR THE WORLD CHAMPIONSHIP! ğŸ‰<br>Start the finals â†’";
            b.onclick = initWorldCupFinals;
            c.appendChild(b);
          } else {
            const msg = document.createElement("div");
            msg.style.cssText = "padding:20px;background:rgba(239,68,68,0.1);border:1px solid rgba(239,68,68,0.3);border-radius:8px;color:#fca5a5;text-align:center;font-size:16px;margin-bottom:10px;";
            msg.innerHTML = "âŒ Unfortunately you did not qualify for the World Championship.<br>Try again!";
            c.appendChild(msg);
          }
        }
        
        const bk = document.createElement("button");
        bk.className = "b br";
        bk.style.marginTop = "6px";
        bk.textContent = "Exit";
        bk.onclick = bMenu;
        c.appendChild(bk);
      }
      
      function findNextWCQM() {
        // First, try to find user's next match
        for (const g of G.wcQualifiers.groups) {
          for (const m of g.matches) {
            if (!m.played && (m.home.code === G.wcQualifiers.user.code || m.away.code === G.wcQualifiers.user.code)) {
              return { g, m, isUser: true };
            }
          }
        }
        
        // If no user match, find any match
        for (const g of G.wcQualifiers.groups) {
          for (const m of g.matches) {
            if (!m.played) {
              return { g, m, isUser: false };
            }
          }
        }
        
        return null;
      }
      
      function simWCQM(nm) {
        const r = simMatch(nm.m.home, nm.m.away);
        nm.m.hg = r.hg;
        nm.m.ag = r.ag;
        nm.m.played = true;
      }
      
      function simAllNonUserWCQ() {
        let nm;
        while ((nm = findNextWCQM()) !== null) {
          const iu =
            nm.m.home.code === G.wcQualifiers.user.code ||
            nm.m.away.code === G.wcQualifiers.user.code;
          if (iu) break;
          simWCQM(nm);
        }
      }
      
      function playWCQM(nm) {
        G.wcqMatch = nm; // MegjegyezzÃ¼k a selejtezÅ‘ meccset
        G.ht = nm.m.home;
        G.at = nm.m.away;
        G.af = Object.keys(FMS)[Math.floor(Math.random() * Object.keys(FMS).length)];
        if (nm.m.home.code !== G.wcQualifiers.user.code) {
          [G.ht, G.at] = [G.at, G.ht];
          const tmp = G.hf;
          G.hf = G.af;
          G.af = tmp;
        }
        startM();
      }
      
      function checkWCQualification() {
        // MegnÃ©zzÃ¼k hogy a user kvalifikÃ¡lt-e
        const userTeam = G.wcQualifiers.user;
        
        for (const g of G.wcQualifiers.groups) {
          if (!g.teams.some(t => t.code === userTeam.code)) continue;
          
          const st = calcSt(g);
          const userPos = st.findIndex(s => s.team.code === userTeam.code);
          
          if (G.wcQualifiers.continent === 'CONMEBOL') {
            // DÃ©l-Amerika: top 6
            return userPos < 6;
          } else {
            // MÃ¡s kontinensek: csoportelsÅ‘k
            return userPos === 0;
          }
        }
        return false;
      }
      
      function initWorldCupFinals() {
        // World Cup torna indÃ­tÃ¡sa a kvalifikÃ¡lt csapatokkal
        hAll();
        
        // Ã–sszegyÅ±jtjÃ¼k az Ã¶sszes kvalifikÃ¡lt csapatot kontinensenkÃ©nt
        const qualifiedTeams = [];
        
        // TODO: Itt kellene egy komplex rendszer ami minden kontinensrÅ‘l Ã¶sszegyÅ±jti a kvalifikÃ¡ltakat
        // EgyszerÅ±sÃ­tve: csak a legjobb 32 csapatot vesszÃ¼k
        const allTeams = [...TEAMS].sort((a, b) => a.rank - b.rank).slice(0, 32);
        
        // 8 csoport Ã— 4 csapat
        const pots = [
          allTeams.slice(0, 8),
          allTeams.slice(8, 16),
          allTeams.slice(16, 24),
          allTeams.slice(24, 32),
        ];
        
        pots.forEach((p) => {
          for (let i = p.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [p[i], p[j]] = [p[j], p[i]];
          }
        });
        
        const groups = [];
        for (let i = 0; i < 8; i++) {
          const g = {
            name: String.fromCharCode(65 + i),
            teams: [pots[0][i], pots[1][i], pots[2][i], pots[3][i]],
            matches: [],
          };
          
          for (let a = 0; a < 4; a++) {
            for (let b = a + 1; b < 4; b++) {
              g.matches.push({
                home: g.teams[a],
                away: g.teams[b],
                hg: null,
                ag: null,
                played: false,
              });
            }
          }
          groups.push(g);
        }
        
        G.cup = { 
          user: G.ht, 
          groups, 
          phase: "groups", 
          ko: null,
          type: 'WC'
        };
        showCup();
      }

      function simCupM(nm) {
        const r = simMatch(nm.m.home, nm.m.away);
        nm.m.hg = r.hg;
        nm.m.ag = r.ag;
        nm.m.played = true;
      }
      function simAllNonUser() {
        let nm;
        while ((nm = findNextGM()) !== null) {
          const iu =
            nm.m.home.code === G.cup.user.code ||
            nm.m.away.code === G.cup.user.code;
          if (iu) break;
          simCupM(nm);
        }
      }

      function playCupM(nm) {
        G.ht = nm.m.home;
        G.at = nm.m.away;
        G.af =
          Object.keys(FMS)[Math.floor(Math.random() * Object.keys(FMS).length)];
        if (nm.m.home.code !== G.cup.user.code) {
          [G.ht, G.at] = [G.at, G.ht];
          const tmp = G.hf;
          G.hf = G.af;
          G.af = tmp;
        }
        G.cup._cur = nm;
        startM();
      }

      function cupMO() {
        // EllenÅ‘rizzÃ¼k hogy selejtezÅ‘ meccs volt-e
        if (G.wcqMatch) {
          const nm = G.wcqMatch;
          let hg = G.hs, ag = G.as;
          if (nm.m.home.code === G.ht.code) {
            nm.m.hg = hg;
            nm.m.ag = ag;
          } else {
            nm.m.hg = ag;
            nm.m.ag = hg;
          }
          nm.m.played = true;
          G.wcqMatch = null;
          
          // SzimulÃ¡ljuk a tÃ¶bbi meccset is
          simulateOneRoundForOthersWCQ();
          showWCQualifiers();
          return;
        }
        
        // NormÃ¡l kupa meccs
        const nm = G.cup._cur;
        if (nm) {
          let hg = G.hs,
            ag = G.as;
          if (nm.m.home.code === G.ht.code) {
            nm.m.hg = hg;
            nm.m.ag = ag;
          } else {
            nm.m.hg = ag;
            nm.m.ag = hg;
          }
          nm.m.played = true;
          
          // ÃšJDONSÃG: Amikor a user lejÃ¡tszik 1 meccset, 
          // minden mÃ¡s csapat is jÃ¡tszik 1 meccset
          if (G.cup.phase === "groups") {
            simulateOneRoundForOthers();
          }
        }
        if (G.cup.phase === "knockout") {
          cupKOMO();
          return;
        }
        showCup();
      }
      
      function simulateOneRoundForOthersWCQ() {
        // Simulate 1 match for each group
        G.wcQualifiers.groups.forEach((g) => {
          const nextMatch = g.matches.find((m) => {
            if (m.played) return false;
            return m.home.code !== G.wcQualifiers.user.code && m.away.code !== G.wcQualifiers.user.code;
          });
          
          if (nextMatch) {
            const r = simMatch(nextMatch.home, nextMatch.away);
            nextMatch.hg = r.hg;
            nextMatch.ag = r.ag;
            nextMatch.played = true;
          }
        });
      }
      
      // Results viewer for Cup
      function showResults() {
        hAll();
        document.getElementById("cup").classList.add("a");
        const c = document.getElementById("cupc");
        c.innerHTML = "<h1 class='t'>ğŸ“Š Match Results</h1>";
        
        // Group matches by round
        const maxRound = Math.max(...G.cup.groups.flatMap(g => g.matches.filter(m => m.played).map((m, i) => Math.floor(i / (g.teams.length / 2)) + 1)));
        
        // Create tabs for each round
        const tabContainer = document.createElement("div");
        tabContainer.style.cssText = "display:flex;gap:4px;margin-bottom:12px;overflow-x:auto;";
        
        for (let round = 1; round <= maxRound; round++) {
          const tab = document.createElement("button");
          tab.className = "b";
          tab.style.cssText = "flex-shrink:0;padding:8px 16px;font-size:12px;";
          tab.textContent = `Match ${round}`;
          tab.onclick = () => showResultsRound(round);
          tabContainer.appendChild(tab);
        }
        c.appendChild(tabContainer);
        
        // Show first round by default
        showResultsRound(1);
        
        const bBack = document.createElement("button");
        bBack.className = "b b2";
        bBack.style.marginTop = "12px";
        bBack.textContent = "Back";
        bBack.onclick = showCup;
        c.appendChild(bBack);
      }
      
      function showResultsRound(roundNum) {
        const c = document.getElementById("cupc");
        // Remove previous round results if any
        const existing = document.getElementById("roundResults");
        if (existing) existing.remove();
        
        const resultsDiv = document.createElement("div");
        resultsDiv.id = "roundResults";
        
        resultsDiv.innerHTML = `<h2 class="s">Matchday ${roundNum}</h2>`;
        
        // Show all matches from this round across all groups
        G.cup.groups.forEach((g) => {
          const roundMatches = [];
          let matchIndex = 0;
          
          g.matches.forEach((m, idx) => {
            const currentRound = Math.floor(idx / (g.teams.length / 2)) + 1;
            if (currentRound === roundNum && m.played) {
              roundMatches.push(m);
            }
          });
          
          if (roundMatches.length > 0) {
            const groupDiv = document.createElement("div");
            groupDiv.style.cssText = "margin-bottom:12px;padding:8px;background:#1f2937;border-radius:6px;";
            groupDiv.innerHTML = `<div style="font-weight:700;margin-bottom:6px;">Group ${g.name}</div>`;
            
            roundMatches.forEach(m => {
              const matchDiv = document.createElement("div");
              matchDiv.className = "mr";
              matchDiv.innerHTML = `${m.home.flag} ${m.home.code} <b>${m.hg}-${m.ag}</b> ${m.away.code} ${m.away.flag}`;
              groupDiv.appendChild(matchDiv);
            });
            
            resultsDiv.appendChild(groupDiv);
          }
        });
        
        // Insert before the back button
        const backBtn = c.querySelector(".b2");
        c.insertBefore(resultsDiv, backBtn);
      }
      
      // Results viewer for WC Qualifiers
      function showResultsWCQ() {
        hAll();
        document.getElementById("cup").classList.add("a");
        const c = document.getElementById("cupc");
        c.innerHTML = "<h1 class='t'>ğŸ“Š Qualifier Results</h1>";
        
        // Group matches by round
        const maxRound = Math.max(...G.wcQualifiers.groups.flatMap(g => g.matches.filter(m => m.played).map((m, i) => Math.floor(i / (g.teams.length / 2)) + 1)));
        
        // Create tabs
        const tabContainer = document.createElement("div");
        tabContainer.style.cssText = "display:flex;gap:4px;margin-bottom:12px;overflow-x:auto;";
        
        for (let round = 1; round <= maxRound; round++) {
          const tab = document.createElement("button");
          tab.className = "b";
          tab.style.cssText = "flex-shrink:0;padding:8px 16px;font-size:12px;";
          tab.textContent = `Match ${round}`;
          tab.onclick = () => showResultsRoundWCQ(round);
          tabContainer.appendChild(tab);
        }
        c.appendChild(tabContainer);
        
        showResultsRoundWCQ(1);
        
        const bBack = document.createElement("button");
        bBack.className = "b b2";
        bBack.style.marginTop = "12px";
        bBack.textContent = "Back";
        bBack.onclick = showWCQualifiers;
        c.appendChild(bBack);
      }
      
      function showResultsRoundWCQ(roundNum) {
        const c = document.getElementById("cupc");
        const existing = document.getElementById("roundResults");
        if (existing) existing.remove();
        
        const resultsDiv = document.createElement("div");
        resultsDiv.id = "roundResults";
        resultsDiv.innerHTML = `<h2 class="s">Matchday ${roundNum}</h2>`;
        
        G.wcQualifiers.groups.forEach((g) => {
          const roundMatches = [];
          
          g.matches.forEach((m, idx) => {
            const currentRound = Math.floor(idx / (g.teams.length / 2)) + 1;
            if (currentRound === roundNum && m.played) {
              roundMatches.push(m);
            }
          });
          
          if (roundMatches.length > 0) {
            const groupDiv = document.createElement("div");
            groupDiv.style.cssText = "margin-bottom:12px;padding:8px;background:#1f2937;border-radius:6px;";
            groupDiv.innerHTML = `<div style="font-weight:700;margin-bottom:6px;">Group ${g.name}</div>`;
            
            roundMatches.forEach(m => {
              const matchDiv = document.createElement("div");
              matchDiv.className = "mr";
              matchDiv.innerHTML = `${m.home.flag} ${m.home.code} <b>${m.hg}-${m.ag}</b> ${m.away.code} ${m.away.flag}`;
              groupDiv.appendChild(matchDiv);
            });
            
            resultsDiv.appendChild(groupDiv);
          }
        });
        
        const backBtn = c.querySelector(".b2");
        c.insertBefore(resultsDiv, backBtn);
      }
      
      function simulateOneRoundForOthers() {
        // Minden csoportban keressÃ¼k meg a kÃ¶vetkezÅ‘ nem jÃ¡tszott meccset
        G.cup.groups.forEach((g) => {
          // KeressÃ¼k meg az elsÅ‘ lejÃ¡tszatlan meccset ami NEM a user-t Ã©rinti
          const nextMatch = g.matches.find((m) => {
            if (m.played) return false;
            // Csak akkor szimulÃ¡ljuk, ha a user egyik csapata sem jÃ¡tszik benne
            const userPlaying = 
              m.home.code === G.cup.user.code || 
              m.away.code === G.cup.user.code;
            return !userPlaying;
          });
          
          if (nextMatch) {
            const result = simMatch(nextMatch.home, nextMatch.away);
            nextMatch.hg = result.hg;
            nextMatch.ag = result.ag;
            nextMatch.played = true;
          }
        });
      }

      // Knockout
      function startFinalTournament() {
        // Move from qualifying to final tournament
        // Collect qualified teams (top 2 from each group)
        const qualifiedTeams = [];
        G.cup.groups.forEach(g => {
          const standings = calcSt(g);
          qualifiedTeams.push(standings[0].team); // 1st place
          qualifiedTeams.push(standings[1].team); // 2nd place
        });
        
        // Create tournament groups based on cup type
        const tournamentConfig = {
          'EURO': { groups: 6, teamsPerGroup: 4 }, // 24 teams
          'AFCON': { groups: 6, teamsPerGroup: 4 }, // 24 teams
          'COPA': { groups: 4, teamsPerGroup: 4 }, // 16 teams (already done)
          'AFC': { groups: 6, teamsPerGroup: 4 }, // 24 teams
          'CONCACAF': { groups: 4, teamsPerGroup: 4 } // 16 teams
        };
        
        const config = tournamentConfig[G.cup.type];
        const numTournamentTeams = config.groups * config.teamsPerGroup;
        
        // Take qualified teams
        const tournamentTeams = qualifiedTeams.slice(0, numTournamentTeams);
        
        // Create tournament groups
        const tournamentGroups = [];
        for (let i = 0; i < config.groups; i++) {
          const g = {
            name: String.fromCharCode(65 + i),
            teams: [],
            matches: [],
          };
          
          // Distribute teams (pot-based)
          for (let j = 0; j < config.teamsPerGroup; j++) {
            const teamIndex = j * config.groups + i;
            if (teamIndex < tournamentTeams.length) {
              g.teams.push(tournamentTeams[teamIndex]);
            }
          }
          
          // Generate matches
          for (let a = 0; a < g.teams.length; a++) {
            for (let b = a + 1; b < g.teams.length; b++) {
              g.matches.push({
                home: g.teams[a],
                away: g.teams[b],
                hg: null,
                ag: null,
                played: false,
              });
            }
          }
          
          tournamentGroups.push(g);
        }
        
        // Update cup object
        G.cup.groups = tournamentGroups;
        G.cup.phase = "groups"; // Tournament group stage
        showCup();
      }
      
      function initKO() {
        G.cup.phase = "knockout";
        
        // Get knockoutTeams config
        const cupConfig = {
          'EURO': 16,
          'AFCON': 16,
          'COPA': 8,
          'AFC': 16,
          'CONCACAF': 8
        };
        const targetKnockoutTeams = cupConfig[G.cup.type] || 16;
        
        // Collect all standings
        const allStandings = [];
        G.cup.groups.forEach((g) => {
          const st = calcSt(g);
          st.forEach((standing, pos) => {
            allStandings.push({
              ...standing,
              groupName: g.name,
              position: pos + 1 // 1st, 2nd, 3rd, 4th
            });
          });
        });
        
        // Qualified teams
        const qualified = [];
        
        // 1. All group winners (1st place)
        const firsts = allStandings.filter(s => s.position === 1);
        qualified.push(...firsts);
        
        // 2. All runners-up (2nd place)
        const seconds = allStandings.filter(s => s.position === 2);
        qualified.push(...seconds);
        
        // 3. Best 3rd place teams (if needed)
        if (qualified.length < targetKnockoutTeams) {
          const thirds = allStandings
            .filter(s => s.position === 3)
            .sort((a, b) => {
              // Sort by: points â†’ goal diff â†’ goals scored
              if (b.pts !== a.pts) return b.pts - a.pts;
              const gd_a = (a.gf || 0) - (a.ga || 0);
              const gd_b = (b.gf || 0) - (b.ga || 0);
              if (gd_b !== gd_a) return gd_b - gd_a;
              return (b.gf || 0) - (a.gf || 0);
            });
          
          const needed = targetKnockoutTeams - qualified.length;
          qualified.push(...thirds.slice(0, needed));
        }
        
        // Take only target number
        const knockoutTeams = qualified.slice(0, targetKnockoutTeams).map(s => s.team);
        
        // Copa America special case: 2 groups, top 4 each â†’ 8 teams knockout
        if (G.cup.type === 'COPA' && G.cup.groups.length === 2) {
          // Semi-finals: 1A vs 2B, 1B vs 2A
          const ko = [
            {
              home: firsts[0].team,
              away: seconds[1].team,
              hg: null,
              ag: null,
              played: false,
            },
            {
              home: firsts[1].team,
              away: seconds[0].team,
              hg: null,
              ag: null,
              played: false,
            }
          ];
          G.cup.ko = [ko];
          showCup();
          return;
        }
        
        // Standard bracket (Round of 16, QF, SF, F)
        // Pair teams: 1st vs best 3rd, etc.
        const ko = [];
        
        // Simple pairing: alternate from start and end
        for (let i = 0; i < knockoutTeams.length / 2; i++) {
          ko.push({
            home: knockoutTeams[i],
            away: knockoutTeams[knockoutTeams.length - 1 - i],
            hg: null,
            ag: null,
            played: false,
          });
        }
        
        G.cup.ko = [ko];
        showCup();
      }

      function showKO() {
        const c = document.getElementById("cupc");
        const rounds = G.cup.ko;
        
        // Dynamic round names based on team count
        function getRoundName(numTeams) {
          if (numTeams === 2) return "FINAL";
          if (numTeams === 4) return "Semi-Final";
          if (numTeams === 8) return "Quarter-Final";
          if (numTeams === 16) return "Round of 16";
          return `Round of ${numTeams}`;
        }
        
        const cupNames = {
          'EURO': 'ğŸ† European Championship 2026',
          'AFCON': 'ğŸ† African Championship 2026',
          'COPA': 'ğŸ† South American Cup 2026',
          'AFC': 'ğŸ† Asian Championship 2026',
          'CONCACAF': 'ğŸ† North American Cup 2026',
          'WC': 'ğŸŒ World Championship 2026'
        };
        const cupName = cupNames[G.cup.type] || 'ğŸ† Championship';
        
        c.innerHTML = `<h1 class="t">${cupName} - Knockout Stage</h1>`;
        
        // Show bracket tree (all rounds)
        let bracketHTML = '<div style="margin: 16px 0;">';
        
        for (let roundIdx = 0; roundIdx < rounds.length; roundIdx++) {
          const round = rounds[roundIdx];
          const numTeams = round.length * 2;
          const roundName = getRoundName(numTeams);
          
          bracketHTML += `
            <div style="margin-bottom: 16px;">
              <h3 style="font-size: 14px; color: #facc15; margin-bottom: 8px;">${roundName}</h3>
          `;
          
          round.forEach((m, i) => {
            const iu = m.home.code === G.cup.user.code || m.away.code === G.cup.user.code;
            
            bracketHTML += `
              <div class="mr" style="padding:6px;background:#1f2937;border-radius:6px;margin:3px 0;width:100%;font-size:12px;${iu ? 'border:1px solid #facc15;' : ''}">
            `;
            
            if (m.played) {
              const homeWon = m.hg > m.ag;
              const awayWon = m.ag > m.hg;
              bracketHTML += `
                ${m.home.flag}<b style="color:${homeWon ? '#22c55e' : '#fff'}">${m.home.code}</b> 
                <b>${m.hg}-${m.ag}</b> 
                <b style="color:${awayWon ? '#22c55e' : '#fff'}">${m.away.code}</b>${m.away.flag}
              `;
            } else {
              bracketHTML += `${m.home.flag} ${m.home.code} vs ${m.away.code} ${m.away.flag}`;
            }
            
            bracketHTML += `</div>`;
          });
          
          bracketHTML += `</div>`;
        }
        
        bracketHTML += '</div>';
        c.innerHTML += bracketHTML;

        // Find current round and next match
        const curRound = rounds[rounds.length - 1];
        const nm = curRound.find((m) => !m.played);
        
        if (nm) {
          const iu = nm.home.code === G.cup.user.code || nm.away.code === G.cup.user.code;
          
          if (iu) {
            // User's match - show play button
            const b = document.createElement("button");
            b.className = "b";
            b.style.marginTop = "8px";
            b.textContent = `â–¶ Play Your Match: ${nm.home.flag} ${nm.home.code} vs ${nm.away.code} ${nm.away.flag}`;
            b.onclick = () => playKOM(nm);
            c.appendChild(b);
          } else {
            // AI match - show simulate button
            const b = document.createElement("button");
            b.className = "b b2";
            b.style.marginTop = "8px";
            b.textContent = `â© Simulate: ${nm.home.flag} ${nm.home.code} vs ${nm.away.code} ${nm.away.flag}`;
            b.onclick = () => {
              simKOM(nm);
              showCup();
            };
            c.appendChild(b);
          }
        } else {
          // All matches in current round done
          if (curRound.length === 1) {
            // Tournament over!
            const w = curRound[0].hg > curRound[0].ag ? curRound[0].home : curRound[0].away;
            c.innerHTML += `<div style="margin-top:16px;text-align:center"><div style="font-size:40px">ğŸ†</div><div style="font-family:'Russo One',sans-serif;font-size:24px;color:#facc15;margin:8px 0">${w.flag} ${w.code}</div><div style="color:#9ca3af">${cupName} Champion!</div></div>`;
          } else {
            const b = document.createElement("button");
            b.className = "b bg";
            b.style.marginTop = "8px";
            b.textContent = "Next Round â†’";
            b.onclick = () => {
              const winners = curRound.map((m) =>
                m.hg > m.ag ? m.home : m.away,
              );
              const next = [];
              for (let i = 0; i < winners.length; i += 2)
                next.push({
                  home: winners[i],
                  away: winners[i + 1],
                  hg: null,
                  ag: null,
                  played: false,
                });
              G.cup.ko.push(next);
              showCup();
            };
            c.appendChild(b);
          }
        }
      }

      function simKOM(m) {
        let r;
        do {
          r = simMatch(m.home, m.away);
        } while (r.hg === r.ag);
        m.hg = r.hg;
        m.ag = r.ag;
        m.played = true;
      }

      function playKOM(m) {
        G.cup._curKO = m;
        G.ht = m.home;
        G.at = m.away;
        G.af =
          Object.keys(FMS)[Math.floor(Math.random() * Object.keys(FMS).length)];
        if (m.home.code !== G.cup.user.code) {
          [G.ht, G.at] = [G.at, G.ht];
        }
        startM();
      }

      function cupKOMO() {
        const m = G.cup._curKO;
        if (m) {
          if (m.home.code === G.ht.code) {
            m.hg = G.hs;
            m.ag = G.as;
          } else {
            m.hg = G.as;
            m.ag = G.hs;
          } // If draw, add random extra goal
          if (m.hg === m.ag) {
            if (Math.random() < 0.5) m.hg++;
            else m.ag++;
          }
          m.played = true;
        }
        showCup();
      }

      // Game loop
      // JÃ¡tÃ©kosok mozgÃ¡sa - 4 irÃ¡nyos + tiltÃ³ kÃ¶r (circle collider)
      function updatePlayerMovement() {
        const now = Date.now();
        
        [...G.pl.home, ...G.pl.away].forEach((p) => {
          // GK Ã©s ball owner NEM mozog
          if (p.position === "GK" || p.hb) {
            p.moveState = 'rest';
            return;
          }
          
          // Initialize breathing motion
          if (!p.breathingOffset) {
            p.breathingOffset = Math.random() * Math.PI * 2; // Random phase
            p.breathingSpeed = 0.0005 + Math.random() * 0.0003; // 0.0005-0.0008
          }
          
          // FORMATION TRANSITION (targetBx/targetBy)
          if (p.targetBx !== undefined && p.targetBy !== undefined) {
            const dx = p.targetBx - p.bx;
            const dy = p.targetBy - p.by;
            const dist = Math.hypot(dx, dy);
            
            if (dist > 1) {
              // MUCH SLOWER base speed (6 sec instead of 3 sec)
              let speed = dist / 360; // 360 frames = 6 seconds at 60fps
              
              // Player speed stat - BIG IMPACT
              if (p.speed !== undefined) {
                // Speed 50 = 0.5x slower, Speed 70 = 1.0x normal, Speed 90 = 1.5x faster
                const speedModifier = 0.3 + (p.speed / 100) * 1.2; // 0.3-1.5x range
                speed *= speedModifier;
              }
              
              // Defenders faster when defending
              const isDefender = ['CB', 'LB', 'RB', 'LWB', 'RWB'].includes(p.position);
              const isDefending = (p.team === 'home' && G.poss === 'away') || 
                                   (p.team === 'away' && G.poss === 'home');
              
              if (isDefender && isDefending) {
                speed *= 1.8; // Slightly faster for defenders
              }
              
              // Move towards target
              p.bx += (dx / dist) * Math.min(speed, dist);
              p.by += (dy / dist) * Math.min(speed, dist);
            } else {
              // Reached target
              p.bx = p.targetBx;
              p.by = p.targetBy;
              p.targetBx = undefined;
              p.targetBy = undefined;
            }
          }
          
          // BREATHING MOTION (subtle movement around base position)
          // Role-based movement amount
          let breathingAmplitude;
          const isAttacker = ['LW', 'RW', 'ST', 'CF', 'LF', 'RF'].includes(p.position);
          const isMidfielder = ['CM', 'CDM', 'CAM', 'LM', 'RM'].includes(p.position);
          const isDefender = ['CB', 'LB', 'RB', 'LWB', 'RWB'].includes(p.position);
          
          if (isAttacker) {
            breathingAmplitude = G.fw * 0.055; // RESTORED: Back to 5.5%
          } else if (isMidfielder) {
            breathingAmplitude = G.fw * 0.040; // RESTORED: Back to 4.0%
          } else if (isDefender) {
            breathingAmplitude = G.fw * 0.025; // RESTORED: Back to 2.5%
          } else {
            breathingAmplitude = G.fw * 0.030; // RESTORED
          }
          
          // SPACE-SEEKING: If too close to opponent, move away
          // REDUCED range and SMOOTH movement to avoid bouncing
          const opponentTeam = p.team === 'home' ? G.pl.away : G.pl.home;
          const nearbyOpponent = opponentTeam.find(opp => {
            const dist = Math.hypot(opp.x - p.bx, opp.y - p.by);
            return dist < G.fw * 0.08; // REDUCED: 15% â†’ 8% (much smaller radius!)
          });
          
          if (nearbyOpponent) {
            // Move away from nearby opponent (space seeking)
            // VERY SMOOTH: modify base position gradually
            const awayX = p.bx - nearbyOpponent.x;
            const awayY = p.by - nearbyOpponent.y;
            const awayDist = Math.hypot(awayX, awayY);
            if (awayDist > 0) {
              const escapeFactor = G.fw * 0.02; // REDUCED: 0.04 â†’ 0.02 (50% smaller)
              // VERY gentle push with HEAVY damping (10% instead of 30%)
              p.bx += (awayX / awayDist) * escapeFactor * 0.1;
              p.by += (awayY / awayDist) * escapeFactor * 0.1;
            }
          }
          
          // SOFT COLLISION: RE-ENABLED (ULTRA SMOOTH)
          // Prevent teammates from overlapping (needed after marking system)
          // IMPORTANT: Skip collision during formation transition (would conflict!)
          const isTransitioning = p.targetBx !== undefined && p.targetBy !== undefined;
          
          if (!isTransitioning) {
            // ULTRA gentle push away (smoother than before)
            const teammates = p.team === 'home' ? G.pl.home : G.pl.away;
            teammates.forEach(teammate => {
              if (teammate.id === p.id) return;
              const dx = p.bx - teammate.bx;
              const dy = p.by - teammate.by;
              const dist = Math.hypot(dx, dy);
              
              const minDistance = G.fw * 0.06; // SMALLER: 8% â†’ 6% (tighter spacing OK)
              
              if (dist < minDistance && dist > 0) {
                // ULTRA gentle push (5% of overlap, 5% damping = 0.25% total per frame!)
                const overlap = minDistance - dist;
                const pushForce = overlap * 0.05; // MUCH SMALLER: 15% â†’ 5%
                const pushX = (dx / dist) * pushForce;
                const pushY = (dy / dist) * pushForce;
                
                // ULTRA damping (5% instead of 30%)
                p.bx += pushX * 0.05;
                p.by += pushY * 0.05;
              }
            });
          }
          
          // Circular breathing pattern (smooth sine wave)
          const time = now * p.breathingSpeed + p.breathingOffset;
          const breathX = Math.sin(time) * breathingAmplitude;
          let breathY = Math.cos(time * 0.7) * breathingAmplitude * 0.6; // Elliptical
          
          // SPECIAL: LM/RM/LB/RB get BIGGER Y breathing in attacking if NO LW/RW in formation
          const isAttacking = (p.team === 'home' && G.poss === 'home') || 
                             (p.team === 'away' && G.poss === 'away');
          const isWideMidDefender = ['LM', 'RM', 'LB', 'RB'].includes(p.position);
          
          if (isAttacking && isWideMidDefender) {
            // Check if formation has LW/RW (if yes, normal breathing; if no, BOOST Y)
            const formation = p.team === 'home' ? G.hf : G.af;
            const formationsWithoutWingers = [
              '4-4-2', '3-5-2', '5-3-2', '4-1-4-1', '3-1-4-2', '3-2-3-2',
              '3-2-4-1', '3-4-1-2', '3-4-2-1', '3-5-1-1', '4-1-2-1-2',
              '4-1-3-2', '4-2-2-2', '4-3-1-2', '4-3-2-1', '4-4-1-1',
              '4-5-1', '5-2-1-2', '5-4-1'
            ];
            
            if (formationsWithoutWingers.includes(formation)) {
              // RESTORED: Back to 1.2x boost
              breathY = Math.cos(time * 0.7) * breathingAmplitude * 1.2;
            }
          }
          
          // Apply breathing to current position
          p.x = p.bx + breathX;
          p.y = p.by + breathY;
          
          // Keep in bounds
          p.x = Math.max(G.fx + p.r, Math.min(p.x, G.fx + G.fw - p.r));
          p.y = Math.max(G.fy + p.r, Math.min(p.y, G.fy + G.fh - p.r));
        });
      }
      
      // EllenÅ‘rzi hogy van-e ellenfÃ©l a cÃ©lpozÃ­ciÃ³ kÃ¶zelÃ©ben
      function checkPathBlocked(player, targetX, targetY, radius) {
        const allPlayers = [...G.pl.home, ...G.pl.away];
        for (let other of allPlayers) {
          if (other.id === player.id) continue;
          const dist = Math.hypot(targetX - other.x, targetY - other.y);
          if (dist < radius) {
            return other; // Van blocker
          }
        }
        return null; // Szabad az Ãºt
      }
      
      // EllenÅ‘rzi mennyi hely van egy irÃ¡nyban
      function checkSpace(player, dirX, dirY) {
        const allPlayers = [...G.pl.home, ...G.pl.away];
        const checkDist = G.fw * 0.1;
        const checkX = player.x + dirX * checkDist;
        const checkY = player.y + dirY * checkDist;
        
        let minDist = checkDist;
        for (let other of allPlayers) {
          if (other.id === player.id) continue;
          const dist = Math.hypot(checkX - other.x, checkY - other.y);
          if (dist < minDist) minDist = dist;
        }
        return minDist; // Nagyobb = tÃ¶bb hely
      }
      
      // TiltÃ³ kÃ¶r rendszer - jÃ¡tÃ©kosok nem mehetnek egymÃ¡s kÃ¶rÃ©be
      function applyExclusionCircles(radius) {
        const allPlayers = [...G.pl.home, ...G.pl.away];
        const minDist = radius * 2;
        
        // CSÃ–KKENTVE 3 â†’ 2 iterÃ¡ciÃ³ (kevÃ©sbÃ© agresszÃ­v)
        for (let iteration = 0; iteration < 2; iteration++) {
          for (let i = 0; i < allPlayers.length; i++) {
            for (let j = i + 1; j < allPlayers.length; j++) {
              const p1 = allPlayers[i];
              const p2 = allPlayers[j];
              
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const dist = Math.hypot(dx, dy);
              
              // Ha tÃºl kÃ¶zel vannak (kÃ¶rÃ¶k Ã¡tfednek)
              if (dist < minDist && dist > 0.1) {
                const overlap = minDist - dist;
                const nx = dx / dist;
                const ny = dy / dist;
                
                // PRIORITÃS rendszer:
                // Ha valaki pozÃ­ciÃ³vÃ¡ltÃ¡s kÃ¶zben van (targetBx van), ÅT nem toljuk!
                const p1HasPriority = p1.targetBx !== undefined && p1.targetBy !== undefined;
                const p2HasPriority = p2.targetBx !== undefined && p2.targetBy !== undefined;
                
                let pushDistance = overlap * 0.3;
                
                if (p1HasPriority && !p2HasPriority) {
                  // P1-nek prioritÃ¡sa van â†’ CSAK P2-t toljuk (dupla erÅ‘vel)
                  if (!p2.hb) {
                    p2.x += nx * pushDistance * 2;
                    p2.y += ny * pushDistance * 2;
                  }
                } else if (p2HasPriority && !p1HasPriority) {
                  // P2-nek prioritÃ¡sa van â†’ CSAK P1-et toljuk (dupla erÅ‘vel)
                  if (!p1.hb) {
                    p1.x -= nx * pushDistance * 2;
                    p1.y -= ny * pushDistance * 2;
                  }
                } else {
                  // MindkettÅ‘nek vagy egyiknek sincs prioritÃ¡sa â†’ normÃ¡l tolÃ¡s
                  if (!p1.hb) {
                    p1.x -= nx * pushDistance;
                    p1.y -= ny * pushDistance;
                  }
                  if (!p2.hb) {
                    p2.x += nx * pushDistance;
                    p2.y += ny * pushDistance;
                  }
                }
              }
            }
          }
        }
      }

      // SzÃ¡mÃ­tja egy jÃ¡tÃ©kos mÃ¡gneses taszÃ­tÃ¡sÃ¡t
      function loop() {
        X.clearRect(0, 0, C.width, C.height);
        X.fillStyle = "#0a1628";
        X.fillRect(0, 0, C.width, C.height);
        if (G.state !== "menu") {
          updatePlayerMovement(); // JÃ¡tÃ©kosok mozgÃ¡sa (mÃ¡gneses taszÃ­tÃ¡ssal)
          
          // KRITIKUS: Ha valakinek van labdÃ¡ja, a labda mindig nÃ¡la legyen
          if (G.state === "playing" && G.sel && G.sel.hb) {
            G.ball.x = G.sel.x;
            G.ball.y = G.sel.y;
          }
          
          // Update match timer (90 real seconds = 90 game minutes)
          if (G.state === "playing" && G.matchStartTime) {
            const elapsed = (Date.now() - G.matchStartTime) / 1000; // Real seconds
            G.matchTime = Math.floor(elapsed * G.matchTimerSpeed); // Game minutes
            
            // Update display
            const minutes = Math.min(G.matchTime, 90);
            
            // GOLDEN GOAL MODE (csak knockout stage-nÃ©l Ã©s ha aktÃ­v)
            if (G.goldenGoalMode) {
              document.getElementById("sd").textContent = "GOLDEN GOAL";
            } else {
              document.getElementById("sd").textContent = `${minutes}'`;
            }
            
            // STAMINA REMOVED - no longer used
            
            // End match when time runs out
            if (G.matchTime >= G.matchDuration) {
              // Check if this is knockout stage AND draw
              const isKnockout = G.mode === "cup" && G.cup && G.cup.ko && G.cup.ko.length > 0;
              const isDraw = G.hs === G.as;
              
              if (isKnockout && isDraw && !G.goldenGoalMode) {
                // ENTER GOLDEN GOAL MODE
                G.goldenGoalMode = true;
                G.state = "paused";
                
                // Show Golden Goal popup for 3 seconds
                const popup = document.createElement('div');
                popup.style.cssText = `
                  position: fixed;
                  inset: 0;
                  background: rgba(0,0,0,0.9);
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  z-index: 9999;
                  animation: fadeIn 0.3s;
                `;
                popup.innerHTML = `
                  <div style="
                    font-family: 'Russo One', sans-serif;
                    font-size: 48px;
                    color: #facc15;
                    text-shadow: 0 0 20px rgba(250,204,21,0.5);
                    text-align: center;
                  ">
                    âš¡ GOLDEN GOAL âš¡
                  </div>
                `;
                document.body.appendChild(popup);
                
                setTimeout(() => {
                  popup.remove();
                  G.state = "playing";
                }, 3000);
              } else {
                // Normal end (knockout win/loss, or non-knockout)
                endM();
              }
            }
            
            // GOLDEN GOAL: First goal wins
            if (G.goldenGoalMode && (G.hs !== G.as)) {
              endM();
            }
          }
          
          dF();
          dP();
          dB();
          dAL();
          G.anims.forEach((a) => {
            X.fillStyle = `rgba(${a.color === "#22c55e" ? "34,197,94" : "250,204,21"},${a.a})`;
            X.font = 'bold 13px "Russo One",sans-serif';
            X.textAlign = "center";
            X.fillText(a.text, a.x, a.y);
          });
          if (G.state === "playing" && G.turn === "away") aiT();
        }
        requestAnimationFrame(loop);
      }

      window.addEventListener("resize", () => {
        resize();
        if (G.state !== "menu") initP();
      });
      
      // ============================================
      // PLAYER SYSTEM - Database & Progression
      // ============================================
      
      // Load player database
      async function loadPlayerDatabase() {
        try {
          const response = await fetch('players_database.json');
          G.playersDB = await response.json();
          console.log(`âœ… Loaded ${G.playersDB.length} players`);
          return true;
        } catch (error) {
          console.error('âŒ Failed to load player database:', error);
          // Fallback: Create minimal database
          G.playersDB = [];
          return false;
        }
      }
      
      // Helper functions
      function getPlayerById(id) {
        return G.playersDB.find(p => p.id === id);
      }
      
      function getPlayersByCountry(code) {
        return G.playersDB.filter(p => p.country === code);
      }
      
      function getPlayersByTier(tier) {
        return G.playersDB.filter(p => p.tier === tier);
      }
      
      // Weighted random selection
      function weightedRandom(odds) {
        const random = Math.random();
        let cumulative = 0;
        
        for (const [tier, probability] of Object.entries(odds)) {
          cumulative += probability;
          if (random < cumulative) return tier;
        }
        
        return Object.keys(odds)[Object.keys(odds).length - 1];
      }
      
      // Pack system
      function openPack(packType) {
        const packConfig = {
          bronze: {
            cost: 200,
            cards: 3,
            odds: { common: 0.75, rare: 0.24, epic: 0.01, legendary: 0.00 }
          },
          silver: {
            cost: 500,
            cards: 5,
            odds: { common: 0.60, rare: 0.30, epic: 0.09, legendary: 0.01 }
          },
          gold: {
            cost: 1500,
            cards: 5,
            odds: { common: 0.20, rare: 0.50, epic: 0.25, legendary: 0.05 }
          },
          premium: {
            cost: 3000,
            cards: 7,
            odds: { common: 0, rare: 0.40, epic: 0.45, legendary: 0.15 }
          }
        };
        
        const config = packConfig[packType];
        if (!config) return [];
        
        const pack = [];
        const pulledIds = new Set();
        
        for (let i = 0; i < config.cards; i++) {
          const tier = weightedRandom(config.odds);
          const availablePlayers = G.playersDB.filter(p => 
            p.tier === tier && !pulledIds.has(p.id)
          );
          
          if (availablePlayers.length === 0) continue;
          
          const randomPlayer = availablePlayers[
            Math.floor(Math.random() * availablePlayers.length)
          ];
          
          pack.push(randomPlayer);
          pulledIds.add(randomPlayer.id);
        }
        
        return pack;
      }
      
      // Handle pack opening with duplicates
      function handlePackOpening(pack) {
        const results = [];
        const coinValue = { common: 50, rare: 150, epic: 500, legendary: 2000.00 };
        
        pack.forEach(player => {
          if (G.userCollection.has(player.id)) {
            // DUPLICATE!
            const coins = coinValue[player.tier];
            G.userSquad.coins += coins;
            
            results.push({
              player: player,
              isDuplicate: true,
              coinsEarned: coins
            });
          } else {
            // NEW PLAYER!
            G.userCollection.add(player.id);
            
            results.push({
              player: player,
              isDuplicate: false,
              isNew: true
            });
          }
        });
        
        return results;
      }
      
      // User XP & Leveling
      function addUserXP(amount) {
        G.userSquad.xp += amount;
        
        const levelUps = [];
        
        while (G.userSquad.xp >= G.userSquad.nextLevelXP) {
          G.userSquad.xp -= G.userSquad.nextLevelXP;
          G.userSquad.level++;
          G.userSquad.nextLevelXP = Math.floor(G.userSquad.nextLevelXP * 1.15);
          
          // Level up reward
          const reward = getLevelUpReward(G.userSquad.level);
          levelUps.push({ level: G.userSquad.level, reward });
        }
        
        saveUserData();
        return levelUps;
      }
      
      function getLevelUpReward(level) {
        const rewards = {
          2: { coins: 100 },
          3: { pack: 'bronze' },
          5: { coins: 200, pack: 'silver' },
          10: { pack: 'epic', coins: 500 },
          15: { pack: 'gold', coins: 500 },
          20: { pack: 'legendary', coins: 1000 },
          25: { coins: 1000 },
          30: { pack: 'premium', coins: 2000 },
        };
        
        if (rewards[level]) return rewards[level];
        
        // Every 10 levels
        if (level % 10 === 0) {
          return { coins: 300, pack: 'silver' };
        }
        
        return { coins: 100 };
      }
      
      // Save/Load user data
      function saveUserData() {
        const data = {
          squad: G.userSquad,
          collection: Array.from(G.userCollection),
          timestamp: Date.now()
        };
        
        localStorage.setItem('fm2026_userdata', JSON.stringify(data));
      }
      
      function loadUserData() {
        const saved = localStorage.getItem('fm2026_userdata');
        if (!saved) return null;
        
        try {
          const data = JSON.parse(saved);
          
          G.userSquad = data.squad;
          G.userCollection = new Set(data.collection);
          
          return data;
        } catch (error) {
          console.error('Failed to load user data:', error);
          return null;
        }
      }
      
      // Starter pack for new players
      function giveStarterPack() {
        console.log('ğŸ New player! Giving starter pack...');
        
        // Ensure complete squads for 3 formations: 4-4-2, 5-4-1, 3-4-3
        const neededPositions = {
          "GK": 1,      // Goalkeeper (all formations)
          "CB": 3,      // 3-4-3 needs 3 CBs, 5-4-1 needs 3
          "LB": 1,      // 4-4-2
          "RB": 1,      // 4-4-2
          "LWB": 1,     // 5-4-1
          "RWB": 1,     // 5-4-1
          "CM": 4,      // All formations use CM
          "LM": 1,      // 4-4-2, 5-4-1, 3-4-3
          "RM": 1,      // 4-4-2, 5-4-1, 3-4-3
          "LW": 1,      // 3-4-3
          "RW": 1,      // 3-4-3
          "ST": 2       // 4-4-2, 3-4-3 (one ST in 5-4-1)
        };
        
        const selectedPlayers = new Set();
        
        // For each needed position, find best available player
        Object.entries(neededPositions).forEach(([position, count]) => {
          const candidates = G.playersDB
            .filter(p => p.position === position && !selectedPlayers.has(p.id))
            .sort((a, b) => b.overall - a.overall); // Best first
          
          // Pick required count
          for (let i = 0; i < count && i < candidates.length; i++) {
            selectedPlayers.add(candidates[i].id);
            G.userCollection.add(candidates[i].id);
          }
        });
        
        // Add a few random extra players (bonus)
        const bonusPack = openPack('silver');
        bonusPack.forEach(player => {
          G.userCollection.add(player.id);
        });
        
        G.userSquad.coins = 1000;
        G.userSquad.level = 1;
        G.userSquad.xp = 0;
        G.userSquad.nextLevelXP = 1000;
        G.userSquad.formation = '4-4-2'; // Default formation
        
        saveUserData();
        
        console.log(`âœ… Starter pack: ${G.userCollection.size} players (4-4-2, 5-4-1, 3-4-3) + 1000 coins`);
        return Array.from(selectedPlayers).map(id => getPlayerById(id));
      }
      
      // ============================================
      // SQUAD BUILDER & SHOP UI
      // ============================================
      
      let currentSquadTab = 'lineup';
      let currentTierFilter = 'all';
      let currentPositionFilter = 'all';
      let selectedPositionSlot = null;
      
      // Open Squad Builder
      function openSquadBuilder() {
        document.getElementById('menu').classList.remove('a');
        document.getElementById('squadBuilder').classList.add('a');
        updateSquadBuilderUI();
        renderFormationDisplay();
        renderCollection();
      }
      
      // Close Squad Builder
      function closeSquadBuilder() {
        document.getElementById('squadBuilder').classList.remove('a');
        document.getElementById('menu').classList.add('a');
      }
      
      // Switch Squad Tab
      function switchSquadTab(tab) {
        currentSquadTab = tab;
        
        // Update tab buttons
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        event.target.classList.add('active');
        
        // Show/hide content
        if (tab === 'lineup') {
          document.getElementById('squadLineup').style.display = 'block';
          document.getElementById('squadCollection').style.display = 'none';
        } else {
          document.getElementById('squadLineup').style.display = 'none';
          document.getElementById('squadCollection').style.display = 'block';
          renderCollection();
        }
      }
      
      // Update Squad Builder UI stats
      function updateSquadBuilderUI() {
        document.getElementById('sbLevel').textContent = G.userSquad.level;
        document.getElementById('sbXP').textContent = G.userSquad.xp;
        document.getElementById('sbNextXP').textContent = G.userSquad.nextLevelXP;
        document.getElementById('sbCoins').textContent = G.userSquad.coins;
        document.getElementById('sbPlayers').textContent = G.userCollection.size;
        
        // Optional: Update formation display if element exists
        const formationEl = document.getElementById('squadFormation');
        if (formationEl) {
          formationEl.textContent = G.userSquad.formation;
        }
      }
      
      // Render Formation Display
      function renderFormationDisplay() {
        const display = document.getElementById('formationDisplay');
        const formation = G.userSquad.formation || '4-4-2';
        
        // Highlight selected formation button
        document.querySelectorAll('#squadLineup .fb').forEach(btn => {
          btn.classList.remove('sel');
          if (btn.textContent === formation) {
            btn.classList.add('sel');
          }
        });
        
        const formationPositions = {
          "4-4-2": [
            { pos: "GK", x: 50, y: 95.00 },  // Alul
            { pos: "LB", x: 15, y: 75.00 }, { pos: "CB", x: 35, y: 80.00 }, { pos: "CB", x: 65, y: 80.00 }, { pos: "RB", x: 85, y: 75.00 },
            { pos: "LM", x: 15, y: 50.00 }, { pos: "CM", x: 35, y: 50.00 }, { pos: "CM", x: 65, y: 50.00 }, { pos: "RM", x: 85, y: 50.00 },
            { pos: "ST", x: 35, y: 15.00 }, { pos: "ST", x: 65, y: 15.00 }  // FelÃ¼l
          ],
          "5-4-1": [
            { pos: "GK", x: 50, y: 95.00 },  // Alul
            { pos: "LWB", x: 10, y: 75.00 }, { pos: "CB", x: 28, y: 82.00 }, { pos: "CB", x: 50, y: 85.00 }, { pos: "CB", x: 72, y: 82.00 }, { pos: "RWB", x: 90, y: 75.00 },
            { pos: "LM", x: 15, y: 50.00 }, { pos: "CM", x: 35, y: 50.00 }, { pos: "CM", x: 65, y: 50.00 }, { pos: "RM", x: 85, y: 50.00 },
            { pos: "ST", x: 50, y: 15.00 }  // FelÃ¼l
          ],
          "3-4-3": [
            { pos: "GK", x: 50, y: 95.00 },  // Alul
            { pos: "CB", x: 25, y: 80.00 }, { pos: "CB", x: 50, y: 82.00 }, { pos: "CB", x: 75, y: 80.00 },
            { pos: "LM", x: 15, y: 50.00 }, { pos: "CM", x: 35, y: 50.00 }, { pos: "CM", x: 65, y: 50.00 }, { pos: "RM", x: 85, y: 50.00 },
            { pos: "LW", x: 15, y: 20.00 }, { pos: "ST", x: 50, y: 15.00 }, { pos: "RW", x: 85, y: 20.00 }  // FelÃ¼l
          ]
        };
        
        const positions = formationPositions[formation] || formationPositions["4-4-2"];
        
        let html = '';
        positions.forEach((slot, index) => {
          const player = G.userSquad.players[index] ? getPlayerById(G.userSquad.players[index]) : null;
          
          html += `
            <div class="formation-player-slot ${player ? 'filled' : ''}" 
                 style="left: ${slot.x}%; top: ${slot.y}%; transform: translate(-50%, -50%);"
                 onclick="selectPositionSlot(${index}, '${slot.pos}')">
              <div class="formation-player-circle">
                ${player ? player.overall : slot.pos}
              </div>
              <div class="formation-player-name">
                ${player ? player.name : slot.pos}
              </div>
            </div>
          `;
        });
        
        display.innerHTML = html;
      }
      
      // Change Formation
      function changeFormation(formation) {
        G.userSquad.formation = formation;
        
        // Clear current squad (positions don't match anymore)
        if (confirm(`Change formation to ${formation}?\n\nThis will clear your current lineup.`)) {
          G.userSquad.players = [];
          saveUserData();
          renderFormationDisplay();
          renderCollection();
        }
      }
      
      // Select Position Slot
      function selectPositionSlot(index, position) {
        selectedPositionSlot = { index, position };
        
        // Switch to collection tab
        document.querySelectorAll('.tab')[1].click();
        
        // Auto-filter by compatible positions
        const positionGroups = {
          'GK': 'GK',
          'LB': 'DEF', 'CB': 'DEF', 'RB': 'DEF', 'LWB': 'DEF', 'RWB': 'DEF',
          'CDM': 'MID', 'CM': 'MID', 'CAM': 'MID', 'LM': 'MID', 'RM': 'MID',
          'LW': 'ATT', 'RW': 'ATT', 'ST': 'ATT', 'CF': 'ATT', 'LF': 'ATT', 'RF': 'ATT'
        };
        
        const group = positionGroups[position] || 'all';
        currentPositionFilter = group;
        
        filterCollection();
        
        // Show message
        const msg = position === 'GK' ? 'Select a Goalkeeper' : 
                    group === 'DEF' ? `Select a Defender (preferably ${position})` :
                    group === 'MID' ? `Select a Midfielder (preferably ${position})` :
                    `Select an Attacker (preferably ${position})`;
        
        setTimeout(() => alert(msg), 100);
      }
      
      // Render Collection
      function renderCollection() {
        const grid = document.getElementById('collectionGrid');
        
        // Get owned players
        let players = Array.from(G.userCollection).map(id => getPlayerById(id)).filter(p => p);
        
        // Apply filters
        const search = document.getElementById('collectionSearch')?.value.toLowerCase() || '';
        if (search) {
          players = players.filter(p => 
            p.name.toLowerCase().includes(search) ||
            p.country.toLowerCase().includes(search) ||
            p.position.toLowerCase().includes(search)
          );
        }
        
        if (currentTierFilter !== 'all') {
          players = players.filter(p => p.tier === currentTierFilter);
        }
        
        // Position filter
        if (currentPositionFilter !== 'all') {
          const positionGroups = {
            'GK': ['GK'],
            'DEF': ['LB', 'CB', 'RB', 'LWB', 'RWB'],
            'MID': ['CDM', 'CM', 'CAM', 'LM', 'RM'],
            'ATT': ['LW', 'RW', 'ST', 'CF', 'LF', 'RF']
          };
          
          const allowedPositions = positionGroups[currentPositionFilter] || [];
          players = players.filter(p => allowedPositions.includes(p.position));
        }
        
        // Sort by overall
        players.sort((a, b) => b.overall - a.overall);
        
        // Render
        let html = '';
        players.forEach(player => {
          // FIX: Only first 11 slots count as "in squad" (starting 11)
          const squadStarting11 = G.userSquad.players.slice(0, 11).filter(id => id !== undefined && id !== null);
          const isInSquad = squadStarting11.includes(player.id);
          
          html += `
            <div class="player-card ${player.tier} ${isInSquad ? 'selected' : ''}" 
                 onclick="togglePlayerInSquad(${player.id})">
              <div class="player-card-header">
                <div class="player-card-name">${player.name}</div>
                <div class="player-card-ovr">${player.overall}</div>
              </div>
              <div class="player-card-info">
                <span class="player-card-country">${getCountryFlag(player.country)}</span>
                ${player.position} â€¢ ${player.tier}
                ${isInSquad ? 'âœ“ In Squad' : ''}
              </div>
              <div class="player-card-stats">
                <div class="player-card-stat">
                  <span class="player-card-stat-label">PAC</span>
                  <span>${player.speed}</span>
                </div>
                <div class="player-card-stat">
                  <span class="player-card-stat-label">SHO</span>
                  <span>${player.shooting}</span>
                </div>
                <div class="player-card-stat">
                  <span class="player-card-stat-label">PAS</span>
                  <span>${player.passing}</span>
                </div>
                <div class="player-card-stat">
                  <span class="player-card-stat-label">DEF</span>
                  <span>${player.tackling}</span>
                </div>
              </div>
            </div>
          `;
        });
        
        grid.innerHTML = html || '<div style="color: #6b7280; text-align: center; padding: 20px;">No players found</div>';
      }
      
      // Get country flag
      function getCountryFlag(code) {
        const team = TEAMS.find(t => t.code === code);
        return team ? team.flag : 'ğŸ´';
      }
      
      // Toggle Player in Squad
      function togglePlayerInSquad(playerId) {
        const player = getPlayerById(playerId);
        if (!player) return;
        
        const index = G.userSquad.players.indexOf(playerId);
        
        if (index !== -1) {
          // Remove from squad
          G.userSquad.players.splice(index, 1);
          selectedPositionSlot = null; // Clear selection
        } else {
          // If a position slot is selected, validate position match
          if (selectedPositionSlot) {
            const slotPosition = selectedPositionSlot.position;
            const slotIndex = selectedPositionSlot.index;
            
            // Strict validation for GK
            if (slotPosition === 'GK' && player.position !== 'GK') {
              alert('âŒ This slot requires a Goalkeeper (GK)!');
              return;
            }
            
            if (player.position === 'GK' && slotPosition !== 'GK') {
              alert('âŒ Goalkeepers can only play in GK position!');
              return;
            }
            
            // Compatible positions check (more flexible for outfield players)
            const compatiblePositions = {
              'LB': ['LB', 'LWB'],
              'CB': ['CB'],
              'RB': ['RB', 'RWB'],
              'LWB': ['LB', 'LWB'],
              'RWB': ['RB', 'RWB'],
              'CDM': ['CDM', 'CM'],
              'CM': ['CM', 'CDM', 'CAM'],
              'CAM': ['CAM', 'CM'],
              'LM': ['LM', 'LW', 'CM'],
              'RM': ['RM', 'RW', 'CM'],
              'LW': ['LW', 'LM', 'ST'],
              'RW': ['RW', 'RM', 'ST'],
              'ST': ['ST', 'CF', 'LW', 'RW'],
              'CF': ['CF', 'ST', 'CAM']
            };
            
            const allowed = compatiblePositions[slotPosition] || [slotPosition];
            
            if (!allowed.includes(player.position)) {
              alert(`âŒ Position mismatch!\n\nSlot: ${slotPosition}\nPlayer: ${player.name} (${player.position})\n\nAllowed: ${allowed.join(', ')}`);
              return;
            }
            
            // Add to specific slot
            G.userSquad.players[slotIndex] = playerId;
            selectedPositionSlot = null;
          } else {
            // Add to squad (max 23)
            if (G.userSquad.players.length >= 23) {
              alert('Squad is full! (Maximum 23 players)');
              return;
            }
            
            G.userSquad.players.push(playerId);
          }
        }
        
        saveUserData();
        renderCollection();
        renderFormationDisplay();
      }
      
      // Filter Collection
      function filterCollection() {
        renderCollection();
      }
      
      // Filter by Tier
      function filterByTier(tier) {
        currentTierFilter = tier;
        
        // Update buttons
        document.querySelectorAll('#squadCollection .fb').forEach(btn => {
          btn.classList.remove('sel');
        });
        event.target.classList.add('sel');
        
        renderCollection();
      }
      
      // Filter by Position
      function filterByPosition(group) {
        currentPositionFilter = group;
        
        // Update buttons (position filter buttons are separate)
        const positionButtons = document.querySelectorAll('#squadCollection .fb');
        // Don't clear tier buttons, only update position buttons
        event.target.classList.toggle('sel');
        
        renderCollection();
      }
      
      // Auto-Select Best XI
      function autoSelectBest() {
        const formation = G.userSquad.formation || '4-4-2';
        const positions = {
          "4-4-2": ["GK", "LB", "CB", "CB", "RB", "LM", "CM", "CM", "RM", "ST", "ST"],
          "5-4-1": ["GK", "LWB", "CB", "CB", "CB", "RWB", "LM", "CM", "CM", "RM", "ST"],
          "3-4-3": ["GK", "CB", "CB", "CB", "LM", "CM", "CM", "RM", "LW", "ST", "RW"]
        }[formation] || ["GK", "LB", "CB", "CB", "RB", "LM", "CM", "CM", "RM", "ST", "ST"];
        
        console.log('ğŸ¤– Auto-selecting for formation:', formation);
        console.log('ğŸ“‹ Required positions:', positions);
        console.log('ğŸ‘¥ Total players in collection:', G.userCollection.size);
        
        // Compatible positions map (same as togglePlayerInSquad)
        const compatiblePositions = {
          'GK': ['GK'],
          'LB': ['LB', 'LWB'],
          'CB': ['CB'],
          'RB': ['RB', 'RWB'],
          'LWB': ['LB', 'LWB'],
          'RWB': ['RB', 'RWB'],
          'CDM': ['CDM', 'CM'],
          'CM': ['CM', 'CDM', 'CAM'],
          'CAM': ['CAM', 'CM'],
          'LM': ['LM', 'LW', 'CM'],
          'RM': ['RM', 'RW', 'CM'],
          'LW': ['LW', 'LM', 'ST'],
          'RW': ['RW', 'RM', 'ST'],
          'ST': ['ST', 'CF', 'LW', 'RW'],
          'CF': ['CF', 'ST', 'CAM']
        };
        
        G.userSquad.players = [];
        
        positions.forEach((slotPos, i) => {
          const allowedPositions = compatiblePositions[slotPos] || [slotPos];
          
          // Find best player from compatible positions
          const candidates = Array.from(G.userCollection)
            .map(id => getPlayerById(id))
            .filter(p => p && allowedPositions.includes(p.position) && !G.userSquad.players.includes(p.id))
            .sort((a, b) => {
              // Prefer exact position match, then overall
              const aExact = a.position === slotPos ? 1 : 0;
              const bExact = b.position === slotPos ? 1 : 0;
              if (aExact !== bExact) return bExact - aExact;
              return b.overall - a.overall;
            });
          
          if (candidates.length > 0) {
            console.log(`âœ“ Slot ${i} (${slotPos}): ${candidates[0].name} (${candidates[0].position}, ${candidates[0].overall})`);
            G.userSquad.players.push(candidates[0].id);
          } else {
            console.log(`âœ— Slot ${i} (${slotPos}): No player found!`);
            // No compatible player - leave slot empty
            G.userSquad.players.push(null);
          }
        });
        
        saveUserData();
        renderFormationDisplay();
        renderCollection();
        
        const filled = G.userSquad.players.filter(id => id !== null).length;
        console.log(`âœ… Auto-select complete: ${filled}/11 positions filled`);
        alert(`Auto-selected ${filled}/11 players!${filled < 11 ? '\n\nSome positions could not be filled.' : ''}`);
      }
      
      // ============================================
      // SHOP
      // ============================================
      
      // Open Shop
      function openShop() {
        document.getElementById('menu').classList.remove('a');
        document.getElementById('shop').classList.add('a');
        updateShopUI();
      }
      
      // Close Shop
      function closeShop() {
        document.getElementById('shop').classList.remove('a');
        document.getElementById('menu').classList.add('a');
      }
      
      // Update Shop UI
      function updateShopUI() {
        document.getElementById('shopCoins').textContent = G.userSquad.coins;
      }
      
      // FORMATIONS SYSTEM
      const FORMATION_UNLOCK = {
  // Tier 1 - Beginner (Level 1-5)
  "4-4-2": { level: 1, unlocked: true },  // Default
  "4-3-3": { level: 2, unlocked: false },
  "3-5-2": { level: 3, unlocked: false },
  "5-3-2": { level: 4, unlocked: false },
  "4-5-1": { level: 5, unlocked: false },
  
  // Tier 2 - Intermediate (Level 6-10)
  "4-2-3-1": { level: 6, unlocked: false },
  "3-4-3": { level: 7, unlocked: false },
  "5-4-1": { level: 8, unlocked: false },
  "4-1-4-1": { level: 9, unlocked: false },
  "4-4-1-1": { level: 10, unlocked: false },
  
  // Tier 3 - Advanced (Level 11-15)
  "3-4-1-2": { level: 11, unlocked: false },
  "4-3-1-2": { level: 12, unlocked: false },
  "3-4-2-1": { level: 13, unlocked: false },
  "4-3-2-1": { level: 14, unlocked: false },
  "5-2-3": { level: 15, unlocked: false },
  
  // Tier 4 - Expert (Level 16-20)
  "4-2-4": { level: 16, unlocked: false },
  "3-1-4-2": { level: 17, unlocked: false },
  "4-2-2-2": { level: 18, unlocked: false },
  "3-2-4-1": { level: 19, unlocked: false },
  "5-2-1-2": { level: 20, unlocked: false },
  
  // Tier 5 - Master (Level 21-25)
  "4-1-2-3": { level: 21, unlocked: false },
  "3-2-3-2": { level: 22, unlocked: false },
  "4-1-3-2": { level: 23, unlocked: false },
  "5-2-2-1": { level: 24, unlocked: false },
  "3-5-1-1": { level: 25, unlocked: false },
  
  // Tier 6 - Legendary (Level 26-27)
  "4-1-2-1-2": { level: 26, unlocked: false },
  "4-2-3-1": { level: 27, unlocked: false }  // Advanced variant
};

let currentSelectedFormation = "4-4-2";

function openFormationsMenu() {
  // Update unlock status based on current level
  const userLevel = G.userSquad?.level || 1;
  Object.keys(FORMATION_UNLOCK).forEach(fm => {
    FORMATION_UNLOCK[fm].unlocked = userLevel >= FORMATION_UNLOCK[fm].level;
  });
  
  // Show overlay
  document.getElementById('formationsMenu').classList.add('a');
  
  // Build carousel
  buildFormationCarousel();
  
  // Show current squad formation
  currentSelectedFormation = G.userSquad?.formation || "4-4-2";
  updateFormationPreview(currentSelectedFormation);
}

function closeFormationsMenu() {
  document.getElementById('formationsMenu').classList.remove('a');
}

function buildFormationCarousel() {
  const carousel = document.getElementById('formationCarousel');
  const currentFormation = G.userSquad?.formation || "4-4-2";
  
  // Sort: current first, then unlocked, then locked
  const formations = Object.keys(FORMATION_UNLOCK).sort((a, b) => {
    if (a === currentFormation) return -1;
    if (b === currentFormation) return 1;
    if (FORMATION_UNLOCK[a].unlocked && !FORMATION_UNLOCK[b].unlocked) return -1;
    if (!FORMATION_UNLOCK[a].unlocked && FORMATION_UNLOCK[b].unlocked) return 1;
    return FORMATION_UNLOCK[a].level - FORMATION_UNLOCK[b].level;
  });
  
  carousel.innerHTML = formations.map(fm => {
    const isUnlocked = FORMATION_UNLOCK[fm].unlocked;
    const isCurrent = fm === currentFormation;
    const requiredLevel = FORMATION_UNLOCK[fm].level;
    
    return `
      <div onclick="updateFormationPreview('${fm}')" style="
        min-width: 140px;
        background: ${isUnlocked ? '#1f2937' : '#111827'};
        border: 2px solid ${isCurrent ? '#facc15' : '#374151'};
        border-radius: 8px;
        padding: 12px;
        cursor: pointer;
        scroll-snap-align: start;
        position: relative;
        opacity: ${isUnlocked ? '1' : '0.5'};
      ">
        ${!isUnlocked ? `<div style="position:absolute;top:8px;right:8px;font-size:20px;">ğŸ”’</div>` : ''}
        ${isCurrent ? `<div style="position:absolute;top:8px;right:8px;color:#10b981;font-size:14px;">âœ“</div>` : ''}
        
        <div style="
          font-family: 'Russo One', sans-serif;
          font-size: 18px;
          color: ${isUnlocked ? '#facc15' : '#6b7280'};
          text-align: center;
          margin-bottom: 8px;
        ">${fm}</div>
        
        <canvas id="miniCanvas_${fm}" width="120" height="90" style="width:100%;height:auto;border-radius:4px;"></canvas>
        
        <div style="
          font-size: 10px;
          color: #9ca3af;
          text-align: center;
          margin-top: 6px;
        ">${isUnlocked ? 'Available' : `Level ${requiredLevel}`}</div>
      </div>
    `;
  }).join('');
  
  // Draw mini formations
  setTimeout(() => {
    formations.forEach(fm => {
      drawMiniFormation(fm);
    });
    
    // Scroll carousel to show first card
    const carouselEl = document.getElementById('formationCarousel');
    if (carouselEl) {
      carouselEl.scrollLeft = 0; // Reset to start
    }
  }, 50);
}

function updateFormationPreview(formationName) {
  currentSelectedFormation = formationName;
  const isUnlocked = FORMATION_UNLOCK[formationName].unlocked;
  const isCurrent = formationName === (G.userSquad?.formation || "4-4-2");
  const requiredLevel = FORMATION_UNLOCK[formationName].level;
  
  // Update name
  document.getElementById('selectedFormationName').textContent = formationName;
  
  // Update status
  const statusEl = document.getElementById('selectedFormationStatus');
  if (!isUnlocked) {
    statusEl.textContent = `ğŸ”’ LOCKED (Level ${requiredLevel} required)`;
    statusEl.style.color = '#ef4444';
  } else if (isCurrent) {
    statusEl.textContent = 'âœ“ CURRENT FORMATION';
    statusEl.style.color = '#10b981';
  } else {
    statusEl.textContent = 'âœ“ UNLOCKED';
    statusEl.style.color = '#facc15';
  }
  
  // Update select button
  const selectBtn = document.getElementById('selectFormationBtn');
  if (!isUnlocked) {
    selectBtn.textContent = `ğŸ”’ UNLOCK AT LEVEL ${requiredLevel}`;
    selectBtn.style.background = '#6b7280';
    selectBtn.disabled = true;
  } else if (isCurrent) {
    selectBtn.textContent = 'âœ“ ALREADY SELECTED';
    selectBtn.style.background = '#10b981';
    selectBtn.disabled = true;
  } else {
    selectBtn.textContent = 'âœ“ SELECT THIS FORMATION';
    selectBtn.style.background = '#3b82f6';
    selectBtn.disabled = false;
  }
  
  // Draw big preview
  drawBigFormation(formationName);
}


function drawBigFormation(formationName) {
  const canvas = document.getElementById('formationPreviewCanvas');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  const w = canvas.width;
  const h = canvas.height;
  
  // CsÃ­kos pÃ¡lya
  const stripeWidth = h / 15;
  for (let i = 0; i < 15; i++) {
    ctx.fillStyle = i % 2 === 0 ? '#1a6e3a' : '#156332';
    ctx.fillRect(0, i * stripeWidth, w, stripeWidth);
  }
  
  ctx.strokeStyle = 'rgba(255,255,255,0.9)';
  ctx.lineWidth = 2;
  ctx.strokeRect(8, 8, w - 16, h - 16);
  ctx.beginPath();
  ctx.moveTo(8, h/2);
  ctx.lineTo(w - 8, h/2);
  ctx.stroke();
  ctx.beginPath();
  ctx.arc(w/2, h/2, h * 0.12, 0, Math.PI * 2);
  ctx.stroke();
  
  const goalW = w * 0.18;
  const penaltyW = w * 0.45;
  const penaltyH = h * 0.18;
  const smallBoxW = w * 0.22;
  const smallBoxH = h * 0.08;
  
  ctx.strokeRect((w - penaltyW) / 2, h - penaltyH - 8, penaltyW, penaltyH);
  ctx.strokeRect((w - smallBoxW) / 2, h - smallBoxH - 8, smallBoxW, smallBoxH);
  ctx.strokeRect((w - goalW) / 2, h - 5, goalW, 6);
  ctx.strokeRect((w - penaltyW) / 2, 8, penaltyW, penaltyH);
  ctx.strokeRect((w - smallBoxW) / 2, 8, smallBoxW, smallBoxH);
  ctx.strokeRect((w - goalW) / 2, 3, goalW, 6);
  
  // ATTACKING FORMATION (teljes pÃ¡lya)
  const formation = FMS[formationName];
  if (!formation) return;
  
  const players = formation.a; // ATTACKING!
  
  players.forEach(p => {
    const x = p.x * (w - 16) + 8;
    const y = p.y * (h - 16) + 8; // NO INVERT - attacking uses full field
    
    const radius = 14;
    
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.arc(x + 1, y + 1, radius, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.strokeStyle = '#d1d5db';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    ctx.fillStyle = '#000000';
    ctx.font = 'bold 10px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(p.p, x, y);
  });
}

function drawMiniFormation(formationName) {
  const canvas = document.getElementById(`miniCanvas_${formationName}`);
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  const w = canvas.width;
  const h = canvas.height;
  
  const stripeWidth = h / 10;
  for (let i = 0; i < 10; i++) {
    ctx.fillStyle = i % 2 === 0 ? '#1a6e3a' : '#156332';
    ctx.fillRect(0, i * stripeWidth, w, stripeWidth);
  }
  
  ctx.strokeStyle = 'rgba(255,255,255,0.5)';
  ctx.lineWidth = 1;
  ctx.strokeRect(2, 2, w - 4, h - 4);
  ctx.beginPath();
  ctx.moveTo(2, h/2);
  ctx.lineTo(w - 2, h/2);
  ctx.stroke();
  
  // ATTACKING (teljes pÃ¡lya)
  const formation = FMS[formationName];
  if (!formation) return;
  
  const players = formation.a; // ATTACKING!
  
  players.forEach(p => {
    const x = p.x * (w - 4) + 2;
    const y = p.y * (h - 4) + 2; // NO INVERT
    
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(x, y, 5, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#cccccc';
    ctx.lineWidth = 1;
    ctx.stroke();
  });
}

function selectFormation() {
  if (!G.userSquad) return;
  if (!FORMATION_UNLOCK[currentSelectedFormation].unlocked) return;
  
  // Update squad formation
  G.userSquad.formation = currentSelectedFormation;
  saveUserData();
  
  // Update UI
  document.getElementById('currentFormation').textContent = currentSelectedFormation;
  updateFormationPreview(currentSelectedFormation);
  buildFormationCarousel();
  
  // Update formation display in squad builder
  if (typeof updateFormationDisplay === 'function') {
    updateFormationDisplay();
  }
}
      // Buy Pack
      function buyPack(packType) {
        const packPrices = {
          bronze: 200,
          silver: 500,
          gold: 1500,
          premium: 3000
        };
        
        const price = packPrices[packType];
        
        if (G.userSquad.coins < price) {
          alert(`Not enough coins! You need ${price} ğŸ’°`);
          return;
        }
        
        // Deduct coins
        G.userSquad.coins -= price;
        saveUserData();
        updateShopUI();
        updateDebugUI();
        
        // Open pack
        const pack = openPack(packType);
        const results = handlePackOpening(pack);
        
        // Show pack opening animation
        showPackOpening(results, packType);
      }
      
      // Show Pack Opening Animation
      function showPackOpening(results, packType) {
        const container = document.getElementById('packCard');
        
        let html = `
          <div style="font-family: 'Russo One', sans-serif; font-size: 24px; color: #facc15; margin-bottom: 16px;">
            ${packType.toUpperCase()} PACK
          </div>
        `;
        
        results.forEach(result => {
          const player = result.player;
          const tierColors = {
            legendary: '#fbbf24',
            epic: '#a855f7',
            rare: '#3b82f6',
            common: '#6b7280'
          };
          
          html += `
            <div style="
              background: linear-gradient(135deg, #1f2937, #111827);
              border: 2px solid ${tierColors[player.tier]};
              border-radius: 8px;
              padding: 12px;
              margin-bottom: 10px;
              text-align: left;
            ">
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                  <div style="font-family: 'Russo One', sans-serif; font-size: 16px; color: #fff;">
                    ${player.name}
                  </div>
                  <div style="font-size: 11px; color: #9ca3af;">
                    ${getCountryFlag(player.country)} ${player.position} â€¢ ${player.tier}
                  </div>
                </div>
                <div style="font-family: 'Russo One', sans-serif; font-size: 24px; color: ${tierColors[player.tier]};">
                  ${player.overall}
                </div>
              </div>
              ${result.isDuplicate ? `
                <div style="font-size: 12px; color: #facc15; margin-top: 6px;">
                  âš ï¸ DUPLICATE! +${result.coinsEarned} ğŸ’°
                </div>
              ` : `
                <div style="font-size: 12px; color: #22c55e; margin-top: 6px;">
                  âœ“ NEW PLAYER!
                </div>
              `}
            </div>
          `;
        });
        
        container.innerHTML = html;
        document.getElementById('packOpening').classList.add('active');
        
        saveUserData();
        updateDebugUI();
      }
      
      // Close Pack Opening
      function closePackOpening() {
        document.getElementById('packOpening').classList.remove('active');
        updateShopUI();
        updateSquadBuilderUI();
      }
      
      // Initialize player system
      async function initPlayerSystem() {
        console.log('ğŸ”„ Initializing player system...');
        
        // Load database
        const dbLoaded = await loadPlayerDatabase();
        if (!dbLoaded) {
          console.warn('âš ï¸ Running without player database');
          return;
        }
        
        // Load user data or create new
        const userData = loadUserData();
        
        if (!userData) {
          // New player
          giveStarterPack();
        } else {
          console.log(`âœ… Welcome back! Level ${G.userSquad.level}, ${G.userSquad.coins} coins`);
        }
        
        // Show debug UI ONLY in main menu
        updateDebugUI();
        // Don't show it here - will be shown/hidden by menu state
      }
      
      // Update debug UI
      function updateDebugUI() {
        const debugLevel = document.getElementById('debugLevel');
        const debugXP = document.getElementById('debugXP');
        const debugNextXP = document.getElementById('debugNextXP');
        const debugCoins = document.getElementById('debugCoins');
        const debugPlayers = document.getElementById('debugPlayers');
        
        if (debugLevel) debugLevel.textContent = G.userSquad.level;
        if (debugXP) debugXP.textContent = G.userSquad.xp;
        if (debugNextXP) debugNextXP.textContent = G.userSquad.nextLevelXP;
        if (debugCoins) debugCoins.textContent = G.userSquad.coins;
        if (debugPlayers) debugPlayers.textContent = G.userCollection.size;
      }
      
      // Initialize on load
      initPlayerSystem().then(() => {
        console.log('âœ… Player system ready!');
      });
      
      resize();
      loop();
    </script>
  </body>
</html>




